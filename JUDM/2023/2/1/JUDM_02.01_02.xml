<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.3 20210610//EN" "JATS-journalpublishing1-3.dtd">
<article xml:lang="en" dtd-version="1.3" article-type="research-article" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <front>
    <journal-meta>
      <journal-id journal-id-type="publisher-id">JUDM</journal-id>
      <journal-id journal-id-type="doi">10.56578</journal-id>
      <journal-title-group>
        <journal-title>Journal of Urban Development and Management</journal-title>
        <abbrev-journal-title abbrev-type="issn">J. Urban Dev. Manag.</abbrev-journal-title>
        <abbrev-journal-title abbrev-type="publisher">JUDM</abbrev-journal-title>
      </journal-title-group>
      <issn publication-format="electronic">2957-9597</issn>
      <issn publication-format="print">2957-9589</issn>
      <publisher>
        <publisher-name>Acadlore</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="publisher-id">AR-31fF-XzRbfrUaxjk7EZiEIV5MMWHJFpj</article-id>
      <article-id pub-id-type="doi">10.56578/judm020102</article-id>
      <title-group>
        <article-title>Wounded Triage, Transport and Coordination of Emergency Operation in Urban Emergencies</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <xref ref-type="aff" rid="1">1</xref>
          <name>
            <surname>Yang</surname>
            <given-names>Feng</given-names>
          </name>
          <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0002-2870-6270</contrib-id>
          <email>yf@hactcm.edu.cn</email>
        </contrib>
        <contrib contrib-type="author">
          <xref ref-type="aff" rid="2">2</xref>
          <name>
            <surname>Chong</surname>
            <given-names>Dashuang</given-names>
          </name>
          <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0002-1634-740X</contrib-id>
          <email>chongdashuang@hactcm.edu.cn</email>
        </contrib>
        <aff id="1">College of Management, Henan University of Chinese Medicine, 450046 Zhengzhou, China</aff>
        <aff id="2">School of Information Technology, Henan University of Chinese Medicine, 450046 Zhengzhou, China</aff>
      </contrib-group>
      <year>2023</year>
      <volume>2</volume>
      <issue>1</issue>
      <fpage>14</fpage>
      <lpage>21</lpage>
      <page-range>14-21</page-range>
      <history>
        <date date-type="received">
          <month>01</month>
          <day>17</day>
          <year>2023</year>
        </date>
        <date date-type="accepted">
          <month>03</month>
          <day>14</day>
          <year>2023</year>
        </date>
        <date date-type="pub">
          <month>03</month>
          <day>30</day>
          <year>2023</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>©2023 by the authors</copyright-statement>
        <copyright-year>2023</copyright-year>
        <license>. Licensee Acadlore Publishing Services Limited, Hong Kong. This article can be downloaded for free, and reused and quoted with a citation of the original published version, under the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 license</ext-link>.</license>
      </permissions>
      <abstract><p>For the wounded triage, transport and cooperative scheduling problem of emergency surgery in urban emergency rescue, this study uses the idea of supply chain collaborative scheduling, considers factors such as the number of the wounded, rescue vehicle capacity and hospital operation time to achieve the optimization goals of the shortest rescue response time and the most economical transportation capacity, establishes a mixed integer programming model, and designs a two-stage scheduling algorithm to solve the model. It uses the relative gap between the maximum time span of the entire rescue process and the optimal performance under ideal conditions to measure the performance of the algorithm. The simulation experiments show that the two-stage scheduling algorithm has better problem-solving ability for scenarios with larger number of the wounded and stronger carrying capacity, and has better performance than MFF algorithm and MBF algorithm.</p></abstract>
      <kwd-group>
        <kwd>Urban emergency</kwd>
        <kwd>Collaborative scheduling</kwd>
        <kwd>Mixed integer programming model</kwd>
        <kwd>Two-stage scheduling algorithm</kwd>
      </kwd-group>
      <counts>
        <count count-type="contributors">2</count>
        <fig-count>3</fig-count>
        <table-count>0</table-count>
        <ref-count>9</ref-count>
      </counts>
    </article-meta>
  </front>
  <body>
    <sec disp-level="level1" sec-type="intro">
      <title>1. Introduction</title>
      <p>In the emergency rescue, the wounded triage, transshipment and emergency surgery constitute the complete process of emergency rescue. Due to the shortage of resources involved in the rescue, it is necessary to strengthen the close cooperation among various rescue jobs and coordinate the implementation in order to complete it efficiently. rescue work. With the development of network information technology, all kinds of data can be shared well, and real-time information of each rescue link can be obtained conveniently. Therefore, it is necessary to organically combine the wounded triage, transshipment and emergency surgery to form a complete rescue chain for collaborative scheduling.</p><p>The rescue chain in emergency rescue is similar to the supply chain in industrial production. It belongs to the collaborative scheduling problem of rescue transportation under the condition of limited vehicles. It can use a similar supply chain processing method to achieve collaborative optimization. At present, there is no literature on combining all links in emergency rescue to achieve collaborative scheduling, let alone using supply chain methods to study the optimization of emergency rescue processes, so this study herein is theoretically innovative.</p><p>Many scholars have studied from different perspectives on the problem of production and transportation collaborative scheduling in the supply chain, and have obtained many good results. Liu [<xref ref-type="bibr" rid="ref_1">1</xref>] studied the production and transportation collaborative scheduling problem and divided the transportation into two stages; with the research goal of minimizing the sum of the manufacturing span time and the total installation cost, he proposed two genetic algorithms, and illustrated the improved genetic algorithm through simulation experiments. The algorithm can solve the problem very well and has better performance than the basic genetic algorithm. Garcia and Lozano [<xref ref-type="bibr" rid="ref_2">2</xref>] studied the collaborative scheduling under multiple constraints such as limited productivity, vehicle quantity and order time window, gave an integer programming model, and used the tabu search algorithm to solve it. Niu and Han [<xref ref-type="bibr" rid="ref_3">3</xref>] proposed a two-stage scheduling algorithm based on the unit manufacturing problem, which solves the problem through process decomposition and algorithm optimization. The scheduling algorithm uses a combination of "accurate" calculation and "approximate" solution. This method not only improves the computational efficiency but also takes into account the global optimization goal. Hu et al. [<xref ref-type="bibr" rid="ref_4">4</xref>] studied the single-machine ordering problem of collaborative scheduling of processing and transportation. The optimization goal is to minimize the arrival time of the last workpiece sent to the customer, and an optimal algorithm for this problem is given, and is proved that the worst case bound is 3/2. Ng et al. [<xref ref-type="bibr" rid="ref_5">5</xref>] studied the single-machine, serial batch, and total completion time scheduling problems with priority constraints, same release date and processing time, and proposed a dynamic programming algorithm with time complexity as <italic>O </italic>(n5). Liu et al. [<xref ref-type="bibr" rid="ref_6">6</xref>] studied the batch scheduling problem under the condition of unlimited capacity of the batch machine, with the goal of minimizing the total completion time, and proved that the problem is NP.</p><p>This study uses the idea of supply chain of industrial manufacturing to analyze the collaborative scheduling of each rescue link in emergency rescue, fully considers the number of wounded and the capacity of rescue vehicles, realizes the scheduling process with the shortest rescue response time and the most economical capacity, establishes a mathematical model, designs an optimization algorithm, and analyzes the performance of the algorithm, and finally tests the actual effect of the algorithm through simulation.</p>
    </sec>
    <sec disp-level="level1" sec-type="">
      <title>2. Problem description</title>
      <p>After an emergency occurs, the rescue force goes deep into the disaster area, and first triages the wounded rescued. Therefore, it is necessary to open up a field as a place for triage. Due to the shortage of medical rescue forces, the wounded must enter the triage field for queuing and the triage adopts the combination of fuzzy qualitative method and quantitative scoring method. The wounded who are triaged according to their injuries are transported to the hospital in batches by rescue vehicles for further surgical treatment. This process forms a complete rescue chain, and only the collaborative scheduling of each rescue link can ensure efficient and fast rescue. The rescue chain process is shown in <xref ref-type="fig" rid="fig_1">Figure 1</xref>.</p>
      
        <fig id="fig_1">
          <label>Figure 1</label>
          <caption>Emergency rescue chain process</caption>
          <abstract/>
          <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2023/2/img_lSa4KsFUUdeN34Z9.png"/>
        </fig>
      
      <p>Assuming that <italic>n</italic> wounded persons {<italic>W</italic><sub>1</sub>, <italic>W</italic><sub>2</sub>, …, <italic>W<sub>n</sub></italic>} arrives at the triage field dynamically, these wounded need to undergo triage in the triage field. Due to the urgency of the rescue, the triage operation is a continuous batch operation, the wounded are sent batch by batch and receive triage one by one, and the end time of the triage is equal to the completion time of the last one in this batch of wounded. The ordering count value of the wounded <italic>W<sub>i</sub></italic> and the time spent in the triage process are recorded as <italic>s<sub>i</sub></italic><span> </span>and <italic>p<sub>i</sub></italic>, the time to arrive at the triage field is recorded as <italic>r<sub>i</sub></italic>. Denote the triage time of <italic>b<sub>k</sub> </italic>batch of wounded who received triage on the triage field as <italic>P<sup>k</sup></italic>, then</p>
      
        <disp-formula>
          <label>(1)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msup>
              <mi>P</mi>
              <mi>k</mi>
            </msup>
            <mo>=</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <munder>
              <mo data-mjx-texclass="OP">∑</mo>
              <mrow data-mjx-texclass="ORD">
                <msub>
                  <mi>W</mi>
                  <mi>i</mi>
                </msub>
                <msub>
                  <mi>b</mi>
                  <mi>k</mi>
                </msub>
                <mo>∈</mo>
              </mrow>
            </munder>
            <msub>
              <mi>p</mi>
              <mi>i</mi>
            </msub>
            <mi>i</mi>
            <mi>n</mi>
            <mn>1</mn>
            <mn>2</mn>
          </math>
        </disp-formula>
      
      <p>Assume that the carrying capacity of the vehicle is <italic>c</italic>. Due to the limited number of medical personnel, each batch of wounded must queue up for examination, and the waiting time for the wounded is set to be <italic>s</italic>. Obviously, the time of the last wounded entering the triage field in a batch of wounded is the waiting time of this batch of wounded. When a batch of wounded has been examined, the batch of wounded are immediately transferred by rescue vehicles. Assume that the one-way travel time of the rescue vehicle from the triage field to the operation hospital is <italic>T</italic>. When a batch of wounded arrive at the hospital, the batch of wounded will be operated on in the operating room of the hospital. Due to the existence of multiple operating rooms, the emergency rescue operation can be operated on multiple wounded in the same batch at the same time. This mode is a parallel processing machine [<xref ref-type="bibr" rid="ref_7">7</xref>] mode. The operation time of each batch of wounded is equal to a constant <italic><span>P</span></italic>. According to the actual situation of the operation of the wounded, it is assumed <italic>p<sub>i</sub></italic>+<italic>s</italic><span>≥</span><italic><span>P</span></italic><span>, </span><italic><span>i</span></italic><span>=1, 2, …, </span><italic><span>n</span></italic><span>.</span></p>
    </sec>
    <sec disp-level="level1" sec-type="">
      <title>3. Problem modeling</title>
      <p>First, the parameters of the given mathematical model are as follows:</p><p><inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msup>
      <mi>γ</mi>
      <mrow data-mjx-texclass="ORD">
        <mi data-mjx-alternate="1">′</mi>
      </mrow>
    </msup>
  </math>
</inline-formula> is total number of wounded; <italic>i </italic>is the number of the wounded, <italic>i</italic>=1, 2, …, <italic>n</italic>;<italic> s<sub>i</sub></italic> is the counted number of the wounded <italic>i</italic>; <italic>r<sub>i</sub></italic> is the time when the wounded <italic>i</italic> arrives at the triage field; <italic>p<sub>i</sub></italic> is the examination time of the wounded <italic>i</italic> in a certain triage group on the triage field; <italic>P</italic> is the operation time of each batch of wounded in the hospital operating room; <italic>c</italic> is the maximum number of wounded in a batch in the triage field, or the carrying capacity of a transfer vehicle; <italic>L</italic> is the total number of batches, satisfying<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">⌈</mo>
      <mo data-mjx-texclass="CLOSE">⌉</mo>
      <msub>
        <mi>s</mi>
        <mi>i</mi>
      </msub>
      <mrow data-mjx-texclass="ORD">
        <mo>/</mo>
      </mrow>
      <mi>c</mi>
    </mrow>
    <mo>≤</mo>
    <mo>≤</mo>
    <mi>L</mi>
    <mi>n</mi>
  </math>
</inline-formula>; <italic>k</italic>, <italic>f</italic> is the batch number, <italic>k</italic>=1, 2, …, <italic>L</italic>; <italic>s</italic> is the waiting time of wounded in line in the triage field; <italic>T</italic> is the one-way travel time of the rescue vehicle from the triage field to the operation hospital; <italic>M</italic> is a large positive integer. The decision variables defined are as follows:</p><p><italic>x<sub>ik</sub></italic>: If the wounded <italic>i</italic> is assigned to the <italic>k </italic>batch for triage and transfer, then <italic>x<sub>ik</sub></italic>=0; otherwise <italic>x<sub>ik</sub></italic>=1; <italic>y<sub>kf</sub></italic>: If the wounded of the <italic>k</italic> batch in the triage field are triaged before the <italic>f</italic> batch, then <italic>y<sub>kf</sub></italic>=0; otherwise <italic>y<sub>kf</sub></italic>=1; <italic>z<sub>kf</sub></italic>: If the wounded of the <italic>k</italic> batch in the hospital operating room are operated before the <italic>f</italic> batch, then <italic>z<sub>kf</sub></italic>=0; otherwise <italic>z<sub>kf</sub></italic>=1; <italic>P<sup>k</sup></italic>: The sum of the triage time of the wounded in the <italic>k</italic> batch of the triage field; <italic>S<sub>1k</sub></italic>: Triage start time of the wounded in the <italic>k </italic>batch of the triage field; <italic>C<sub>1k</sub></italic>: Triage end time of the wounded in the <italic>k</italic> batch of triage field; <italic>S<sub>2k</sub></italic>: Start time of operation of the wounded in the <italic>k</italic> batch of operating room of the hospital;<italic> C<sub>2k</sub></italic>: End <italic>k</italic> time of operation of the wounded in the <italic>k </italic>batch of operating room of the hospital; <italic>C<sub>max</sub></italic>: The maximum time span of whole rescue process or the duration during which the severest wound in the rescue chain is treated.</p><p>The mixed integer programming model of the problem is as follows:</p>
      
        <disp-formula>
          <label>(2)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mi>Min</mi>
            <msub>
              <mi>C</mi>
              <mrow data-mjx-texclass="ORD">
                <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
              </mrow>
            </msub>
          </math>
        </disp-formula>
      
      <p>s.t.</p>
      
        <disp-formula>
          <label>(3)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <munderover>
              <mo data-mjx-texclass="OP">∑</mo>
              <mrow data-mjx-texclass="ORD">
                <mi>k</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>L</mi>
            </munderover>
            <msub>
              <mi>x</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>i</mi>
                <mi>k</mi>
              </mrow>
            </msub>
            <mo>=</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mn>1</mn>
            <mn>1</mn>
            <mn>2</mn>
            <mstyle scriptlevel="0">
              <mspace width="1em"/>
            </mstyle>
            <mi>i</mi>
            <mi>n</mi>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(4)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <munderover>
              <mo data-mjx-texclass="OP">∑</mo>
              <mrow data-mjx-texclass="ORD">
                <mi>i</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>n</mi>
            </munderover>
            <msub>
              <mi>s</mi>
              <mi>i</mi>
            </msub>
            <msub>
              <mi>x</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>i</mi>
                <mi>k</mi>
              </mrow>
            </msub>
            <mo>⋅</mo>
            <mo>≤</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mi>c</mi>
            <mi>k</mi>
            <mi>L</mi>
            <mn>1</mn>
            <mn>2</mn>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(5)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>S</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>i</mi>
                <mi>k</mi>
              </mrow>
            </msub>
            <msub>
              <mi>r</mi>
              <mi>i</mi>
            </msub>
            <msub>
              <mi>x</mi>
              <mi>i</mi>
            </msub>
            <mo>≥</mo>
            <mo>⋅</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mo>;</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mstyle scriptlevel="0">
              <mspace width="1em"/>
            </mstyle>
            <mi>i</mi>
            <mi>n</mi>
            <mi>k</mi>
            <mi>L</mi>
            <mn>1</mn>
            <mn>2</mn>
            <mn>1</mn>
            <mn>2</mn>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(6)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>C</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>i</mi>
                <mi>k</mi>
              </mrow>
            </msub>
            <msub>
              <mi>S</mi>
              <mrow data-mjx-texclass="ORD">
                <mn>1</mn>
                <mi>k</mi>
              </mrow>
            </msub>
            <msub>
              <mi>x</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>i</mi>
                <mi>k</mi>
              </mrow>
            </msub>
            <msub>
              <mi>p</mi>
              <mi>i</mi>
            </msub>
            <mo>=</mo>
            <mo>+</mo>
            <mo>+</mo>
            <mo>⋅</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mi>s</mi>
            <mi>k</mi>
            <mi>L</mi>
            <munderover>
              <mo data-mjx-texclass="OP">∑</mo>
              <mrow data-mjx-texclass="ORD">
                <mi>i</mi>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <mi>n</mi>
            </munderover>
            <mstyle scriptlevel="0">
              <mspace width="1em"/>
            </mstyle>
            <mn>1</mn>
            <mn>2</mn>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(7)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>C</mi>
              <mrow data-mjx-texclass="ORD">
                <mn>2</mn>
                <mi>k</mi>
              </mrow>
            </msub>
            <msub>
              <mi>S</mi>
              <mrow data-mjx-texclass="ORD">
                <mn>2</mn>
                <mi>k</mi>
              </mrow>
            </msub>
            <mo>=</mo>
            <mo>+</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mi>P</mi>
            <mi>k</mi>
            <mi>L</mi>
            <mn>1</mn>
            <mn>2</mn>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(8)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>C</mi>
              <mrow data-mjx-texclass="ORD">
                <mn>2</mn>
                <mi>k</mi>
              </mrow>
            </msub>
            <msub>
              <mi>S</mi>
              <mrow data-mjx-texclass="ORD">
                <mn>2</mn>
                <mi>k</mi>
              </mrow>
            </msub>
            <mo>=</mo>
            <mo>+</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mi>P</mi>
            <mi>k</mi>
            <mi>L</mi>
            <mstyle scriptlevel="0">
              <mspace width="1em"/>
            </mstyle>
            <mn>1</mn>
            <mn>2</mn>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(9)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>C</mi>
              <mrow data-mjx-texclass="ORD">
                <mn>1</mn>
                <mi>k</mi>
              </mrow>
            </msub>
            <msub>
              <mi>C</mi>
              <mrow data-mjx-texclass="ORD">
                <mn>1</mn>
                <mi>f</mi>
              </mrow>
            </msub>
            <mo>−</mo>
            <mo>+</mo>
            <mo>+</mo>
            <mo>−</mo>
            <mo>≤</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mo>;</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mo>;</mo>
            <mo>≠</mo>
            <msup>
              <mi>P</mi>
              <mi>f</mi>
            </msup>
            <mi>s</mi>
            <mi>M</mi>
            <mi>k</mi>
            <mi>L</mi>
            <mi>f</mi>
            <mi>L</mi>
            <mi>k</mi>
            <mi>f</mi>
            <mrow data-mjx-texclass="INNER">
              <mo data-mjx-texclass="OPEN">(</mo>
              <mo>−</mo>
              <mo data-mjx-texclass="CLOSE">)</mo>
              <mn>1</mn>
              <msub>
                <mi>y</mi>
                <mrow data-mjx-texclass="ORD">
                  <mi>k</mi>
                  <mi>f</mi>
                </mrow>
              </msub>
            </mrow>
            <mn>0</mn>
            <mn>1</mn>
            <mn>2</mn>
            <mn>1</mn>
            <mn>2</mn>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(10)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>z</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>k</mi>
                <mi>f</mi>
              </mrow>
            </msub>
            <msub>
              <mi>z</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>f</mi>
                <mi>k</mi>
              </mrow>
            </msub>
            <mo>+</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mo>;</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mo>;</mo>
            <mo>≠</mo>
            <mn>1</mn>
            <mn>1</mn>
            <mn>2</mn>
            <mn>1</mn>
            <mn>2</mn>
            <mi>k</mi>
            <mi>L</mi>
            <mi>f</mi>
            <mi>L</mi>
            <mi>k</mi>
            <mi>f</mi>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(11)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>C</mi>
              <mrow data-mjx-texclass="ORD">
                <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
              </mrow>
            </msub>
            <msub>
              <mi>C</mi>
              <mrow data-mjx-texclass="ORD">
                <mn>2</mn>
                <mi>k</mi>
              </mrow>
            </msub>
            <mo>≥</mo>
            <mo>,</mo>
            <mo>=</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mo>…</mo>
            <mo>,</mo>
            <mstyle scriptlevel="0">
              <mspace width="1em"/>
            </mstyle>
            <mi>k</mi>
            <mi>L</mi>
            <mn>1</mn>
            <mn>2</mn>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(12)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>x</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>i</mi>
                <mi>k</mi>
              </mrow>
            </msub>
            <mo>∈</mo>
            <mo fence="false" stretchy="false">{</mo>
            <mo>,</mo>
            <mo fence="false" stretchy="false">}</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mn>0</mn>
            <mn>1</mn>
            <mstyle scriptlevel="0">
              <mspace width="1em"/>
            </mstyle>
            <mi mathvariant="normal">∀</mi>
            <mi>i</mi>
            <mi>k</mi>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(13)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>y</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>k</mi>
                <mi>f</mi>
              </mrow>
            </msub>
            <mo>∈</mo>
            <mo fence="false" stretchy="false">{</mo>
            <mo>,</mo>
            <mo fence="false" stretchy="false">}</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mn>0</mn>
            <mn>1</mn>
            <mstyle scriptlevel="0">
              <mspace width="1em"/>
            </mstyle>
            <mi mathvariant="normal">∀</mi>
            <mi>k</mi>
            <mi>f</mi>
          </math>
        </disp-formula>
      
      
        <disp-formula>
          <label>(14)</label>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <msub>
              <mi>z</mi>
              <mrow data-mjx-texclass="ORD">
                <mi>k</mi>
                <mi>f</mi>
              </mrow>
            </msub>
            <mo>∈</mo>
            <mo fence="false" stretchy="false">{</mo>
            <mo>,</mo>
            <mo fence="false" stretchy="false">}</mo>
            <mo>,</mo>
            <mo>,</mo>
            <mn>0</mn>
            <mn>1</mn>
            <mstyle scriptlevel="0">
              <mspace width="1em"/>
            </mstyle>
            <mi mathvariant="normal">∀</mi>
            <mi>k</mi>
            <mi>f</mi>
          </math>
        </disp-formula>
      
      <p>In the model, Formula (2) is the objective function, which represents the span time to minimize the whole rescue. Formulas (3) ~ (14) are constraint conditions, in which, Formula (3) indicates that any wounded can only be assigned to one rescue process batch, and Formula (4) indicates that the total number of all wounded in any batch cannot exceed the transportation capacity of vehicles <italic>c</italic>, Formula (5) indicates that the triage of a batch of wounded must begin on the premise that all the wounded in the batch can arrived, Formula (6) indicates the completion time of a batch of wounded in the triage field, Formulas (7) and (8) represent the start time and end time of a batch of wounded in the operating room of the hospital respectively. Formula (9) shows that there is no overlap in the triage process of the wounded in the triage field. Formula (10) indicates that due to the limitation of hospital surgical resources, any two rescue batches at a certain moment cannot be operated simultaneously in the surgical hospital. Formula (11) indicates the nature of the entire rescue process time, and Formulas (12) ~ (14) indicate the range of values of the decision variable.</p><p>For the above mathematical model, according to the actual situation of emergency rescue, the following theory is considered:</p><p>Lemma 1 If the order of the wounded in the same batch that participates in the triage is interchanged, the scheduling result will not be affected.</p><p>Corollary 1 For any optimal scheduling scheme, if the arrival time of any existing batch of wounded is sorted in increasing order and then undergoes triage, this operation will not affect the optimal nature of the scheduling scheme.</p><p>Lemma 2 In the optimal scheduling scheme, there is an optimal solution, which contains the batch allocation strategy for the wounded. If all the batches are sorted according to the increasing order of preparation time, this operation does not affect the optimal nature of the scheduling scheme, where the batch preparation time is the maximum arrival time of the wounded in the batch.</p><p>Prove Assume that <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub>
      <mi>r</mi>
      <mrow data-mjx-texclass="ORD">
        <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
      </mrow>
    </msub>
    <mo>=</mo>
    <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
    <mrow data-mjx-texclass="ORD">
      <mn>1</mn>
      <mo>≤</mo>
      <mo>≤</mo>
      <mi>i</mi>
      <mi>n</mi>
    </mrow>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">{</mo>
      <mo data-mjx-texclass="CLOSE">}</mo>
      <mi>r</mi>
      <mi>i</mi>
    </mrow>
  </math>
</inline-formula> represents the maximum time for the wounded to arrive at the triage field; in the scheduling scheme, there is a certain batch <italic>b<sub>l</sub></italic> receiving triage at the triage field; at the same time, there are two adjacent wounded batches <italic>b<sub>k</sub></italic> and <italic>b<sub>f</sub></italic> behind the batch <italic>b<sub>l</sub></italic>. Considering the universality, assuming that <italic>r<sub>k</sub></italic>&gt;<italic>r<sub>f</sub></italic> represents the time to arrive at the triage field, it is only necessary to prove that it is still the optimal solution when the triage start time is <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&gt;<italic>S</italic><sub>1</sub><italic><sub>f</sub></italic>. If the end time of the triage of the wounded in the <italic>l</italic> batch of the triage field is <italic>C</italic><sub>1</sub><italic><sub>l</sub></italic>, there are two situations:</p><p>(1) <italic>C</italic><sub>1</sub><italic><sub>l</sub></italic>≥<italic>r<sub>max</sub></italic></p><p>If <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&lt;<italic>S</italic><sub>1</sub><italic><sub>f</sub></italic>, the end time of triage of the batch <italic>b<sub>k</sub></italic> is <italic>C</italic>'<sub>1</sub><italic><sub>k</sub></italic>=<italic>S<sub>1k</sub></italic>+2<italic>s</italic>+<italic>P<sup>f</sup></italic>+<italic>P<sup>k</sup></italic>=<italic>C</italic><sub>1</sub><italic><sub>f</sub></italic>, obviously if the batches <italic>b<sub>k</sub></italic> and <italic>b<sub>f</sub></italic> are interchanged, the solution of the scheduling scheme is still the optimal solution, which does not affect the final result at all, so it is still set <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&gt;<italic>S</italic><sub>1</sub><italic><sub>f</sub></italic>.</p><p>(2) <italic>C<sub>1l</sub></italic>&lt;<italic>r<sub>max</sub></italic></p><p>When <italic>r<sub>f</sub></italic>&lt;<italic>r<sub>k</sub></italic>≤<italic>C<sub>1l</sub></italic>, the same as (1), it can be concluded that the scheduling scheme is still optimal when <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&gt;<italic>S</italic><sub>1</sub><italic><sub>f</sub></italic>. When <italic>r<sub>f</sub></italic>≤<italic>C</italic><sub>1</sub><italic><sub>l</sub></italic>&lt;<italic>r<sub>k</sub></italic>, if <italic>S<sub>1k</sub></italic>&lt;<italic>S<sub>1f</sub></italic>, then <italic>C</italic><sub>1</sub><italic><sub>f</sub></italic>=<italic>r<sub>k</sub></italic>+2<italic>s</italic>+<italic>P<sup>f</sup></italic>+<italic>P<sup>k</sup></italic>; when the batches <italic>b<sub>k</sub></italic> and <italic>b<sub>f</sub></italic> are interchanged, the end time of the batches <italic>b<sub>k</sub></italic> and <italic>b<sub>f</sub></italic> is respectively <italic>C’</italic><sub>1</sub><italic><sub>f</sub></italic>=<italic>C</italic><sub>1</sub><italic><sub>l</sub></italic>+<italic>s</italic>+<italic>P<sup>f</sup></italic> and <italic>C’</italic><sub>1</sub><italic><sub>k</sub></italic>=max{<italic>r<sub>k</sub></italic>+<italic>s</italic>+<italic>P<sup>k</sup></italic>,<italic> C</italic><sub>1</sub><italic><sub>l</sub></italic>+2<italic>s</italic>+<italic>P<sup>f</sup></italic>+<italic>P<sup>k</sup></italic>}, it can be concluded that<italic> C</italic>'<sub>1</sub><italic><sub>k</sub></italic>&lt;<italic>C</italic><sub>1</sub><italic><sub>f</sub></italic>. Obviously, this conclusion does not conform to the nature of the optimal solution, and contradicts the assumption, so the optimal scheduling scheme should satisfy <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&gt;<italic>S</italic><sub>1</sub><italic><sub>f</sub></italic>. When <italic>C</italic><sub>1</sub><italic><sub>l</sub></italic>&lt;<italic>r<sub>f</sub></italic>&lt;<italic>r<sub>k</sub></italic>, if <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&lt;<italic>S</italic><sub>1</sub><italic><sub>f</sub></italic>, then <italic>C</italic><sub>1</sub><italic><sub>f</sub></italic>=<italic>r<sub>k</sub></italic>+2<italic>s</italic>+<italic>P<sup>f</sup></italic>+<italic>P<sup>k</sup></italic>; when batches<italic> b<sub>k</sub></italic> and <italic>b<sub>f</sub></italic> are interchanged, the end time of triage of batches <italic>b<sub>f</sub></italic> and <italic>b<sub>k</sub></italic> is respectively <italic>C</italic>'<sub>1</sub><italic><sub>f</sub></italic>=<italic>r<sub>f</sub></italic>+<italic>s</italic>+<italic>P<sup>f</sup></italic> and<italic> C</italic>'<sub>1</sub><italic><sub>k</sub></italic>=max{<italic>r<sub>k</sub></italic>+<italic>s</italic>+<italic>P<sup>k</sup></italic>,<italic> r<sub>f</sub></italic>+2<italic>s</italic>+<italic>P<sup>f</sup></italic>+<italic>P<sup>k</sup></italic>}, it can be concluded that <italic>C</italic>'<sub>1</sub><italic><sub>k</sub></italic>&lt;<italic>C</italic><sub>1</sub><italic><sub>f</sub></italic>. Obviously, this conclusion does not conform to the nature of the optimal solution, and contradicts the assumption, so the optimal scheduling scheme should satisfy <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&gt;<italic>S</italic><sub>1</sub><italic><sub>f</sub></italic>.</p><p>In summary, when <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&gt;<italic>S</italic><sub>1</sub><italic><sub>f</sub></italic>, it is still the optimal solution, and the lemma is proved.</p><p>Lemma 3 Suppose there is a scheduling scheme <italic>G</italic>, <italic>G</italic>{…, <italic>b<sub>k</sub></italic>, <italic>b<sub>k</sub></italic><sub>+1</sub>,…}, if <italic>b<sub>k</sub></italic><sub>+1</sub>={<italic>W<sub>j</sub></italic>}, <italic>j</italic>=1, 2, …, <italic>n</italic>, satisfies <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&lt;<italic>r<sub>j</sub></italic>&lt;<italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>+<italic>s</italic> and <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <munder>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <msub>
          <mi>W</mi>
          <mi>i</mi>
        </msub>
        <msub>
          <mi>b</mi>
          <mi>k</mi>
        </msub>
        <mo>∈</mo>
      </mrow>
    </munder>
    <msub>
      <mi>s</mi>
      <mi>i</mi>
    </msub>
    <msub>
      <mi>W</mi>
      <mi>j</mi>
    </msub>
    <mo>+</mo>
    <mo>≤</mo>
    <mi>c</mi>
  </math>
</inline-formula>, then when the wounded <italic>W<sub>j</sub></italic> join the batch <italic>b<sub>k</sub></italic>, the scheduling scheme is better than the original scheme.</p><p>Prove From <italic>r<sub>j</sub></italic>&lt;<italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>+<italic>s</italic> and <italic>C</italic><sub>1</sub><italic><sub>k</sub></italic>=<italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>+<italic>s</italic>+<italic>P<sup>k</sup></italic>,<italic> r<sub>j</sub></italic>&lt;<italic>C</italic><sub>1</sub><italic><sub>k</sub></italic> can be obtained; therefore, <italic>C</italic><sub>1(</sub><italic><sub>k</sub></italic><sub>+1)</sub>=<italic>S</italic><sub>1(</sub><italic><sub>k</sub></italic><sub>+1)</sub>+<italic>s</italic>+<italic>P<sup>k</sup></italic><sup>+1</sup>=<italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>+2<italic>s</italic>+<italic>P<sup>k</sup></italic>+<italic>p<sub>j</sub></italic>. Since <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <munder>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <msub>
          <mi>W</mi>
          <mi>i</mi>
        </msub>
        <msub>
          <mi>b</mi>
          <mi>k</mi>
        </msub>
        <mo>∈</mo>
      </mrow>
    </munder>
    <msub>
      <mi>s</mi>
      <mi>i</mi>
    </msub>
    <msub>
      <mi>W</mi>
      <mi>j</mi>
    </msub>
    <mo>+</mo>
    <mo>≤</mo>
    <mi>c</mi>
  </math>
</inline-formula>, there is enough queue space in the <italic>b<sub>k</sub></italic> batch for the wounded<italic> W<sub>j</sub></italic> to join it. If the wounded <italic>W<sub>j</sub></italic> is added to the batch <italic>b<sub>k</sub></italic>, the start and end time of triage of the <italic>b<sub>k</sub></italic> batch in the triage field are updated to <italic>S</italic>'<sub>1</sub><italic><sub>k</sub></italic>=<italic>r<sub>j</sub></italic> and <italic>C</italic>'<sub>1</sub><italic><sub>k</sub></italic>=<italic>S</italic>'<sub>1</sub><italic><sub>k</sub></italic>+<italic>s</italic>+<italic>P<sup>k</sup></italic>+<italic>p<sub>j</sub></italic>=<italic>r<sub>j</sub></italic>+<italic>s</italic>+<italic>P<sup>k</sup></italic>+<italic>p<sub>j</sub></italic> respectively. Therefore, <italic>C</italic>'<sub>1</sub><italic><sub>k</sub>-C</italic><sub>1(</sub><italic><sub>k</sub></italic><sub>+1)</sub>=<italic>r<sub>j</sub></italic>+<italic>s</italic>+<italic>P<sup>k</sup></italic>+<italic>p<sub>j</sub></italic>-(<italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>+2<italic>s</italic>+<italic>P<sup>k</sup></italic>+<italic>p<sub>j</sub></italic>)=<italic>r<sub>j</sub></italic>-<italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>-<italic>s</italic>. Since <italic>r<sub>j</sub></italic>&lt;<italic> S</italic><sub>1</sub><italic><sub>k</sub></italic>+<italic>s</italic>, <italic>C</italic>'<sub>1</sub><italic><sub>k</sub></italic>&lt;<italic>C</italic><sub>1(</sub><italic><sub>k</sub></italic><sub>+1)</sub>. Lemma 3 is proved.</p><p>Lemma 4 Assume that the wounded of two adjacent batches <italic>b<sub>k</sub></italic> and <italic>b<sub>f</sub></italic> are triaged at the triage field, this scheme <italic>π</italic><sup>*</sup> is the optimal scheduling scheme. If <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>&gt;<italic>S</italic><sub>1</sub><italic><sub>f</sub></italic>, then <italic>S</italic><sub>2</sub><italic><sub>k</sub></italic>&gt;<italic>S</italic><sub>2</sub><italic><sub>f</sub></italic>.</p><p>Prove Since the operation mode of the hospital's operating room belongs to the parallel batch machine mode, it is assumed that the earliest time of operation in the hospital's operating room is <italic>E</italic>, and the earliest operation time that the batch <italic>b<sub>k</sub></italic> and <italic>b<sub>f</sub></italic> can be operated is marked as <italic>T<sub>k</sub></italic> and <italic>T<sub>f</sub></italic> respectively, <italic>T<sub>f</sub></italic>=<italic>C</italic><sub>1</sub><italic><sub>f</sub></italic>+<italic>T</italic> and <italic>T<sub>k</sub></italic>=<italic>C</italic><sub>1</sub><italic><sub>k</sub></italic>+<italic>T</italic> can be obtained, so <italic>T<sub>k</sub></italic>&gt;<italic>T<sub>f</sub></italic>. If <italic>S</italic><sub>2</sub><italic><sub>k</sub></italic>&lt;<italic>S</italic><sub>2</sub><italic><sub>f</sub></italic>, then<italic> C</italic><sub>2</sub><italic><sub>f</sub></italic>=max{<italic>T<sub>k</sub></italic>, <italic>E</italic>}+2<italic>P</italic>, where <italic>P</italic> is a constant, representing the operation time of a batch of wounded. If <italic>b<sub>k</sub></italic> and <italic>b<sub>f</sub></italic> are interchanged, the end time of the operation of the <italic>b<sub>k</sub></italic> batch is<italic> C</italic>'<sub>2</sub><italic><sub>k</sub></italic>=max{max{<italic>T<sub>f</sub></italic>, <italic>E</italic>}+<italic>P</italic>,<italic> T<sub>k</sub></italic>}+<italic>P</italic>, then <italic>C</italic>'<sub>2</sub><italic><sub>k</sub></italic>≤<italic>C</italic><sub>2</sub><italic><sub>f</sub></italic>; this conclusion does not conform to the nature of the optimal solution, and contradicts the hypothesis. Therefore,<italic> S</italic><sub>2</sub><italic><sub>k</sub></italic>&gt;<italic>S</italic><sub>2</sub><italic><sub>f</sub></italic>, the lemma is proved.</p><p>In the triage, some special situations may occur, for example, all wounded have the same arrival time <italic>r</italic>, and this special situation is called "the same release moment".</p><p>Lemma 5 In the case of "the same release time", there are <italic>L</italic><sup>*</sup> batches of wounded in an optimal dispatching scheme <italic>π</italic><sup>*</sup>, then <italic>C</italic><sub>max</sub>(<italic>π</italic><sup>*</sup>)=<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msup>
      <mi>L</mi>
      <mo>∗</mo>
    </msup>
    <mo>⋅</mo>
    <mi>S</mi>
  </math>
</inline-formula>+<span style="font-family: 等线"><inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
  </math>
</inline-formula></span>+<italic>T</italic>+<italic>P</italic>.</p><p>Prove Considering this situation, all wounded at time of <italic>r</italic> can be triaged at the triage field. Then, for <italic>b</italic><sub>1</sub>, <italic>C</italic><sub>11</sub>=<italic>S</italic><sub>11</sub>+<italic>s</italic>+<italic>P</italic><sup>1</sup>=<italic>r</italic>+<italic>s</italic>+<italic>P</italic><sup>1</sup> and <italic>C</italic><sub>21</sub>=<italic>S</italic><sub>21</sub>+<italic>P</italic>=<italic>r</italic>+<italic>s</italic>+<italic>P</italic><sup>1</sup>+<italic>T</italic>+<italic>P</italic>. In the same way, for <italic>b</italic><sub>2</sub>, <italic>C</italic><sub>12</sub>=<italic>S</italic><sub>12</sub>+<italic>s</italic>+<italic>P</italic><sup>2</sup>=<italic>r</italic>+2<italic>s</italic>+<italic>P</italic><sup>1</sup>+<italic>P</italic><sup>2</sup>. If it is recorded <italic>C</italic><sub>21</sub> as the triage start time of any new batch, then based on <italic>p<sub>i</sub></italic>+<italic>s</italic>≥<italic>P</italic>, <italic>C</italic><sub>12</sub>+<italic>T</italic>≥<italic>C</italic><sub>21</sub>, get <italic>C</italic><sub>22</sub>=<italic>S</italic><sub>22</sub>+<italic>P</italic>=<italic>r</italic>+2<italic>s</italic>+<italic>P</italic><sup>1</sup>+<italic>P</italic><sup>2</sup>+<italic>T</italic>+<italic>P</italic>; similarly, for the <italic>l</italic> batch, <italic>b<sub>l</sub></italic>, <italic>l</italic>=3, 4, …, <italic>L</italic><sup>*</sup>, <italic>C</italic><sub>1</sub><italic><sub>l</sub></italic>=<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>l</mi>
    <mi>s</mi>
    <mo>⋅</mo>
    <mo>+</mo>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>l</mi>
    </munderover>
    <msup>
      <mi>P</mi>
      <mi>k</mi>
    </msup>
  </math>
</inline-formula><span style="font-family: 等线"> </span>and <italic>C</italic><sub>2</sub><italic><sub>l</sub></italic>=<italic>S</italic><sub>2</sub><italic><sub>l</sub></italic>+<italic>P</italic>=<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>l</mi>
    <mi>s</mi>
    <mo>⋅</mo>
    <mo>+</mo>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>l</mi>
    </munderover>
    <msup>
      <mi>P</mi>
      <mi>k</mi>
    </msup>
  </math>
</inline-formula>+<italic>T</italic>+<italic>P</italic>. Obviously, <italic>C</italic><sub>max</sub>=<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub>
      <mi>C</mi>
      <mrow data-mjx-texclass="ORD">
        <mn>2</mn>
        <msup>
          <mi>L</mi>
          <mo>∗</mo>
        </msup>
      </mrow>
    </msub>
  </math>
</inline-formula>=<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msup>
      <mi>L</mi>
      <mo>∗</mo>
    </msup>
    <msup>
      <mi>P</mi>
      <mi>k</mi>
    </msup>
    <mo>⋅</mo>
    <mo>+</mo>
    <mi>s</mi>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mrow data-mjx-texclass="ORD">
        <msup>
          <mi>L</mi>
          <mo>∗</mo>
        </msup>
      </mrow>
    </munderover>
  </math>
</inline-formula>+<italic>T</italic>+<italic>P</italic>, because <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mrow data-mjx-texclass="ORD">
        <msup>
          <mi>L</mi>
          <mo>∗</mo>
        </msup>
      </mrow>
    </munderover>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <msup>
      <mi>P</mi>
      <mi>k</mi>
    </msup>
    <mo>=</mo>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
  </math>
</inline-formula>, get <italic>C</italic><sub>max</sub>=<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msup>
      <mi>L</mi>
      <mo>∗</mo>
    </msup>
    <mo>⋅</mo>
    <mo>+</mo>
    <mi>s</mi>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
  </math>
</inline-formula>+<italic>T</italic>+<italic>P</italic>.</p><p>From Lemma 5, there are:</p><p>Corollary 2 In the case of "the same release moment", if there are <italic>L</italic> batches in a scheduling scheme <italic>π</italic>, <italic>C</italic><sub>max</sub>(<italic>π</italic>)≥<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msup>
      <mi>L</mi>
      <mo>∗</mo>
    </msup>
    <mo>⋅</mo>
    <mo>+</mo>
    <mi>S</mi>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
  </math>
</inline-formula>+<italic>T</italic>+<italic>P</italic>.</p><p>Corollary 3 In the case of "the same release moment", <italic>C</italic><sub>max</sub>≥<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">⌈</mo>
      <mo data-mjx-texclass="CLOSE">⌉</mo>
      <msub>
        <mi>s</mi>
        <mi>i</mi>
      </msub>
      <mrow data-mjx-texclass="ORD">
        <mo>/</mo>
      </mrow>
      <mi>c</mi>
    </mrow>
    <mo>⋅</mo>
    <mo>+</mo>
    <mi>s</mi>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
  </math>
</inline-formula>+<italic>T</italic>+<italic>P</italic>.</p><p>Lemma 6 In the case of "the same release moment", if there is a scheduling scheme <italic>π</italic> with no extra idle time in the triage and wounded transfer process, then the fewer batches designed in the scheme is, the better the scheduling solution is.</p><p>Prove Assume that in two scheduling schemes <italic>π</italic> and <italic>π</italic>', there is no extra idle time in the process of triage and wounded transfer. The number of batches contained in <italic>π</italic> is <italic>L</italic>, the number of batches contained in <italic>π</italic>' is <italic>L</italic>', and by Lemma 3, <italic>C</italic><sub>max</sub>(<italic>π</italic>)=<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>L</mi>
    <mi>s</mi>
    <mo>⋅</mo>
    <mo>+</mo>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
  </math>
</inline-formula>+<italic>T</italic>+<italic>P</italic> and <italic>C</italic><sub>max</sub>(<italic>π</italic>')=<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msup>
      <mi>L</mi>
      <mrow data-mjx-texclass="ORD">
        <mi data-mjx-alternate="1">′</mi>
      </mrow>
    </msup>
    <mo>⋅</mo>
    <mo>+</mo>
    <mi>s</mi>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
  </math>
</inline-formula>+<italic>T</italic>+<italic>P</italic>, then <italic>C</italic><sub>max</sub>(<italic>π</italic>)-<italic>C</italic><sub>max</sub>(<italic>π</italic>') =<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>L</mi>
    <mi>s</mi>
    <mo>⋅</mo>
    <mo>+</mo>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
  </math>
</inline-formula>+<italic>T</italic>+<italic>P</italic>–(<italic>r</italic>+<inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msup>
      <mi>L</mi>
      <mrow data-mjx-texclass="ORD">
        <mi data-mjx-alternate="1">′</mi>
      </mrow>
    </msup>
    <mo>⋅</mo>
    <mo>+</mo>
    <mi>s</mi>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
  </math>
</inline-formula>+<italic>T</italic>+<italic>P</italic>). If <italic>L≥L</italic>', then <italic>C</italic><sub>max</sub>(<italic>π</italic>)<italic>≥C</italic><sub>max</sub>(<italic>π</italic>'); otherwise, <italic>C</italic><sub>max</sub>(<italic>π</italic>)&lt;<italic><sub>max</sub>(π').</italic></p><p>From Lemma 6, there are:</p><p>Corollary 4 In the case of "the same release time", the optimal scheduling scheme has the least number of batches among all scheduling schemes.</p><p>Lemma 7 In the case of "the same release time", there is an optimal scheduling scheme. If the order of any two wounded batches in this scheme is interchanged, the scheme is still the optimal scheduling scheme.</p><p>Prove Considering the universality, it is assumed that there is an optimal scheduling scheme, which has batches <italic>b<sub>k</sub></italic> and <italic>b<sub>f</sub></italic> and the triage order of the <italic>b<sub>k</sub></italic> batch is close to <italic>b<sub>f</sub></italic>. If all the wounded can receive triage on the triage field at<italic> r</italic>, then <italic>C<sub>1f</sub>=S<sub>1f</sub>+s+P<sup>f</sup></italic> and <italic>C<sub>1k</sub>=S<sub>1k</sub>+s+P<sup>k</sup>=S<sub>1f</sub>+2s+P<sup>f</sup>+P<sup>k</sup></italic>. When the batches b<sub>k</sub> and b<sub>f</sub> are interchanged on the triage field, the start and end time of triage of the batch <italic>b<sub>k</sub></italic> is updated to <italic>S'<sub>1k</sub>=S<sub>1f</sub></italic> and <italic>C'<sub>ik</sub> =S'<sub>ik</sub>+s+P<sup>k</sup></italic> respectively. The end time of triage of the b<sub>f</sub> batch is updated to <italic>C'<sub>if</sub> =C'<sub>ik</sub>+s+P<sup>f</sup>=S<sub>1f</sub>+2s+P<sup>k</sup>+P<sup>f</sup></italic>, then <italic>C<sub>1k</sub>=C'<sub>1f</sub></italic>. According to Lemma 5, the end time of triage of the <italic>b<sub>f</sub></italic> batch is <italic>C<sub>2f</sub>=C'<sub>2k</sub></italic>. Therefore, this scheme remains optimal.</p>
    </sec>
    <sec disp-level="level1" sec-type="">
      <title>4. Algorithm design and performance analysis</title>
      <p>Based on the problem nature of the whole rescue chain of triage, wounded transfer and emergency surgery, this study designs a two-stage scheduling algorithm (TS-A). The first stage of the algorithm is used to solve the scheduling problem when the end time of triage of the <italic>k</italic> batch of wounded in the triage is <italic>C</italic><sub>1</sub><italic><sub>k</sub></italic>&lt;<italic>r</italic><sub>max</sub>, where <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub>
      <mi>r</mi>
      <mrow data-mjx-texclass="ORD">
        <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
      </mrow>
    </msub>
    <mo>=</mo>
    <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">{</mo>
      <mo data-mjx-texclass="CLOSE">}</mo>
      <msub>
        <mi>r</mi>
        <mi>i</mi>
      </msub>
    </mrow>
  </math>
</inline-formula>, i=1,2,...n. The second stage is used to solve the scheduling problem when the start time of triage of the <italic>k</italic> batch of wounded in the triage is <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>≥<italic>r</italic><sub>max</sub>. In the scheduling scheme, the situation of the wounded joining the batch and the order of the batches in the scheme has been determined, the problem of the second stage is equivalent to the case of "the same release time", then all the unscheduled wounded have reached the triage field at the time <italic>r</italic><sub>max</sub>.</p><p>The first stage of TS-A algorithm is based on Lemma 3, and the second stage is based on Lemma 5, 6.6, 6.7 and FFD algorithm [<xref ref-type="bibr" rid="ref_8">8</xref>]. It’s essential to define the ordering rules first. Rule 1: Sort the wounded in the non-decreasing order of the time they arrived at the triage field. If multiple wounded arrive at the same time, then sort them in the non-increasing order of the count value of the wounded. Rule 2: Sort the wounded in the non-increasing order of the count value of wounded arriving at the triage field. The parameters of the TS-A algorithm are defined as: <italic>W</italic>={<italic>W</italic><sub>1</sub>, <italic>W</italic><sub>2</sub>, …, <italic>W<sub>n</sub></italic>}the set of wounded; <italic>A</italic>(<italic>t</italic>) is the set of effectively dispatched wounded at the time <italic>t</italic>; <italic>U</italic>(<italic>t</italic>) represents the set of wounded who do not participate in the scheduling scheme at time <italic>t</italic>; <italic>K</italic>(<italic>t</italic>) represents the set of wounded who do not participate in the scheduling scheme and not belong to <italic>A</italic>(<italic>t</italic>) at time <italic>t</italic>, then <italic>K</italic>(<italic>t</italic>)=<italic>U</italic>(<italic>t</italic>)\<italic>A</italic>(<italic>t</italic>); <italic>B</italic> represents a set of batches in a scheduling; <italic>S<sup>k</sup></italic> represents the total count value of the wounded in the <italic>b<sub>k</sub></italic> batch; <italic>Q</italic> represents the batch number of the wounded who participate in the triage last in the first stage.</p><p>The steps of the first stage of the algorithm are as follows:</p><p>Step 1: Set <italic>k</italic>=1, <italic>b</italic>=<italic>ϕ</italic>, <italic>S</italic><sup>1</sup>=0, <italic>S</italic><sub>11</sub>=<italic>r</italic><sub>1</sub>, <italic>P</italic><sup>1</sup>=0, <italic>t</italic>=<italic>r</italic><sub>1</sub>, <italic>U</italic>(<italic>t</italic>)=<italic>W</italic>, <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>A</mi>
    <mi>t</mi>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
    <mo>=</mo>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">{</mo>
      <mo>∣</mo>
      <mo>=</mo>
      <mo data-mjx-texclass="CLOSE">}</mo>
      <msub>
        <mi>W</mi>
        <mi>i</mi>
      </msub>
      <msub>
        <mi>r</mi>
        <mi>i</mi>
      </msub>
      <mi>t</mi>
    </mrow>
  </math>
</inline-formula>, and <italic>K</italic>(<italic>t</italic>)=<italic>U</italic>(<italic>t</italic>)\<italic>A</italic>(<italic>t</italic>). The wounded in the sets <italic>U</italic>(<italic>t</italic>),<italic> A</italic>(<italic>t</italic>) and <italic>K</italic>(<italic>t</italic>) are sorted according to rule 1.</p><p>Step 2: If <italic>t</italic>≥<italic>r<sub>max</sub></italic>, jump to the second stage; otherwise, jump to Step 3.</p><p>Step 3: According to the ordering rules, determine whether each wounded in the set <italic>A</italic>(<italic>t</italic>) can be added to the <italic>b<sub>k</sub></italic> batch. If <italic>S<sup>k</sup></italic>+<italic>s<sub>i</sub></italic>≤<italic>c</italic>, then <italic>b<sub>k</sub></italic><span style="font-family: MS Mincho, serif">⋃</span><italic>b<sub>k</sub></italic>{<italic>W<sub>i</sub></italic>}, <italic>S<sup>k</sup></italic>=<italic>S<sup>k</sup></italic>+<italic>s<sub>i</sub></italic> and <italic>P<sup>k</sup></italic>=<italic>P<sup>k</sup></italic>+<italic>p<sub>i</sub></italic>. Update the sets <italic>U</italic>(<italic>t</italic>), <italic>A</italic>(<italic>t</italic>) and <italic>K</italic>(<italic>t</italic>).</p><p>Step 4: If <italic>S<sup>k</sup></italic>=<italic>c</italic>, jump to Step 7; otherwise, jump to Step 5.</p><p>Step 5: According to the ordering rules, determine whether each wounded in the set <italic>K</italic>(<italic>t</italic>) can be added to the <italic>b<sub>k</sub></italic> batch. If <italic>S<sup>k</sup></italic>+<italic>s<sub>i</sub></italic>≤<italic>c</italic> and <italic>r<sub>i</sub></italic>≤<italic>αs</italic>+<italic>t</italic>, where the parameter <italic>α</italic>(0≤<italic>α</italic>≤1) has a certain impact on the performance of the algorithm, it is usually taken <italic>α</italic>=0.3 and <italic>s</italic> is the queuing waiting time; if the condition is met, then jump to Step 6; otherwise, jump to Step 7.</p><p>Step 6: Set <italic>b<sub>k</sub></italic><span style="font-family: MS Mincho, serif">⋃</span><italic>b<sub>k</sub></italic>{<italic>W<sub>i</sub></italic>},<italic> S<sup>k</sup></italic>=<italic>S<sup>k</sup></italic>+<italic>s<sub>i</sub></italic>, <italic>P<sup>k</sup></italic>=<italic>P<sup>k</sup></italic>+<italic>p<sub>i</sub></italic> and <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>=<italic>t</italic>, update the set<italic> U</italic>(<italic>t</italic>), jump to Step 8.</p><p>Step 7: For the <italic>b<sub>k</sub></italic> batch for triage, set <italic>B</italic>=<italic>B</italic><span style="font-family: MS Mincho, serif">⋃</span><italic>b<sub>k</sub></italic>, let <italic>t</italic>=<italic>r</italic>+<italic>s</italic>+<italic>P<sup>k</sup></italic> and <italic>C</italic><sub>1</sub><italic><sub>k</sub></italic>=<italic>t</italic>. If <italic>U</italic>(<italic>t</italic>)=<italic>ϕ</italic>, the algorithm stops; otherwise, let <italic>k</italic>=<italic> k</italic>+1, <italic>b<sub>k</sub></italic>=<italic>ϕ</italic>, <italic>S<sup>k</sup></italic>=0 and <italic>P<sup>k</sup></italic>=0, jump to Step 8.</p><p>Step 8: Set <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>t</mi>
    <mo>=</mo>
    <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">{</mo>
      <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
      <mo>,</mo>
      <mo data-mjx-texclass="CLOSE">}</mo>
      <mrow data-mjx-texclass="INNER">
        <mo data-mjx-texclass="OPEN">{</mo>
        <mo>∣</mo>
        <mo>∈</mo>
        <mo stretchy="false">(</mo>
        <mo stretchy="false">)</mo>
        <mo data-mjx-texclass="CLOSE">}</mo>
        <msub>
          <mi>r</mi>
          <mi>i</mi>
        </msub>
        <msub>
          <mi>W</mi>
          <mi>i</mi>
        </msub>
        <mi>U</mi>
        <mi>t</mi>
      </mrow>
      <mi>t</mi>
    </mrow>
  </math>
</inline-formula> and <italic>S</italic><sub>1</sub><italic><sub>k</sub></italic>=<italic>t</italic>, update the sets <italic>A</italic>(<italic>t</italic>) and <italic>K</italic>(<italic>t</italic>), jump to the second stage.</p><p>The steps of the second stage of the algorithm are as follows:</p><p>Step 1: Sort the wounded in the set <italic>U</italic>(<italic>t</italic>) according to ordering rule 2. Set <italic>Q</italic>=<italic>k</italic> and <italic>k</italic>=<italic> k</italic>+1, add the wounded with the set <italic>U</italic>(<italic>t</italic>) with the number of 1 into the <italic>b<sub>k</sub></italic> batch, and then update the set <italic>U</italic>(<italic>t</italic>).</p><p>Step 2: If <italic>U</italic>(<italic>t</italic>)=<italic>ϕ</italic>, stop; otherwise, jump to Step 3.</p><p>Step 3: Set <italic>i</italic>=<italic> i</italic>+1, add the <italic>i</italic> wounded to the batch whose batch number is the smallest and greater than <italic>Q</italic>, and the count value of the wounded should not be greater than <italic>c</italic>-<italic>s<sub>i</sub></italic>, update the set <italic>U</italic>(<italic>t</italic>), and jump to Step 2.</p><p>According to Lemma 2, 4 and 7, when all the wounded are arranged in the first and second stages, these batches start the scheduling process according to the order in which they are generated.</p><p>In order to evaluate the performance of the TS-A algorithm, two lower bounds of the problem under ideal conditions are considered. The first lower bound means that if the problem is specialized that all the wounded have arrived at the triage field at the time <italic>r</italic><sub>min</sub>, then <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub>
      <mi>r</mi>
      <mrow data-mjx-texclass="ORD">
        <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
      </mrow>
    </msub>
    <mo>=</mo>
    <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
    <mrow data-mjx-texclass="ORD">
      <mi>i</mi>
      <mi>n</mi>
      <mo>=</mo>
      <mo>,</mo>
      <mo>,</mo>
      <mo>…</mo>
      <mo>,</mo>
      <mn>1</mn>
      <mn>2</mn>
    </mrow>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">{</mo>
      <mo data-mjx-texclass="CLOSE">}</mo>
      <mi>r</mi>
      <mi>i</mi>
    </mrow>
  </math>
</inline-formula>, denoted as <italic>LB</italic><sub>1</sub>, its lower bound is less than or equal to the lower bound of the original problem. According to Corollary 3, it can be obtained:</p><p style="text-align: center"><inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>L</mi>
    <mi>s</mi>
    <mi>T</mi>
    <mi>P</mi>
    <msub>
      <mi>B</mi>
      <mn>1</mn>
    </msub>
    <msub>
      <mi>r</mi>
      <mrow data-mjx-texclass="ORD">
        <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
      </mrow>
    </msub>
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mo>+</mo>
    <mo>⋅</mo>
    <mo>+</mo>
    <mo>+</mo>
    <mo>+</mo>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">⌈</mo>
      <mo data-mjx-texclass="CLOSE">⌉</mo>
      <msub>
        <mi>s</mi>
        <mi>i</mi>
      </msub>
      <mrow data-mjx-texclass="ORD">
        <mo>/</mo>
      </mrow>
      <mi>c</mi>
    </mrow>
    <munderover>
      <mo data-mjx-texclass="OP">∑</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
  </math>
</inline-formula></p><p>The second lower bound assumes that there is no additional idle time during the operation in the hospital operating room, calculate the minimum arrival time of the wounded, the end time of triage of the first wound batch, the one-way transportation time between the triage field and the hospital, and the sum of the operation time of all batches in the hospital, i.e., <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>L</mi>
    <mi>T</mi>
    <mi>L</mi>
    <mi>P</mi>
    <msub>
      <mi>B</mi>
      <mn>2</mn>
    </msub>
    <msub>
      <mi>r</mi>
      <mrow data-mjx-texclass="ORD">
        <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
      </mrow>
    </msub>
    <mo>=</mo>
    <mo>+</mo>
    <mo>+</mo>
    <mo>+</mo>
    <mo>⋅</mo>
    <msup>
      <mi>P</mi>
      <mn>1</mn>
    </msup>
  </math>
</inline-formula>. As <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msup>
      <mi>P</mi>
      <mn>1</mn>
    </msup>
    <mo>≥</mo>
    <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
    <msub>
      <mrow data-mjx-texclass="ORD"/>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mi>n</mi>
        <mo>=</mo>
        <mo>,</mo>
        <mo>,</mo>
        <mo>…</mo>
        <mn>1</mn>
        <mn>2</mn>
      </mrow>
    </msub>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">{</mo>
      <mo data-mjx-texclass="CLOSE">}</mo>
      <msub>
        <mi>p</mi>
        <mi>i</mi>
      </msub>
    </mrow>
  </math>
</inline-formula>, <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>L</mi>
    <mo>≥</mo>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">⌈</mo>
      <mo data-mjx-texclass="CLOSE">⌉</mo>
      <msub>
        <mi>s</mi>
        <mi>i</mi>
      </msub>
      <mrow data-mjx-texclass="ORD">
        <mo>/</mo>
      </mrow>
      <mi>c</mi>
    </mrow>
  </math>
</inline-formula>, then:</p><p style="text-align: center"><inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>L</mi>
    <mi>s</mi>
    <mi>T</mi>
    <mi>P</mi>
    <msub>
      <mi>B</mi>
      <mn>2</mn>
    </msub>
    <msub>
      <mi>r</mi>
      <mrow data-mjx-texclass="ORD">
        <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
      </mrow>
    </msub>
    <mo>=</mo>
    <mo>+</mo>
    <mo>+</mo>
    <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
    <mo>+</mo>
    <mo>+</mo>
    <mo>⋅</mo>
    <mrow data-mjx-texclass="ORD">
      <mi>i</mi>
      <mi>n</mi>
      <mo>=</mo>
      <mo>,</mo>
      <mo>,</mo>
      <mo>…</mo>
      <mo>,</mo>
      <mn>1</mn>
      <mn>2</mn>
    </mrow>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">{</mo>
      <mo data-mjx-texclass="CLOSE">}</mo>
      <mi>p</mi>
      <mi>i</mi>
    </mrow>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">⌈</mo>
      <mo data-mjx-texclass="CLOSE">⌉</mo>
      <msub>
        <mi>s</mi>
        <mi>i</mi>
      </msub>
      <mrow data-mjx-texclass="ORD">
        <mo>/</mo>
      </mrow>
      <mi>c</mi>
    </mrow>
  </math>
</inline-formula></p><p>Therefore, for the whole process of the rescue chain, the optimal performance under ideal conditions is the maximum value of the above two lower bounds, i.e.,</p><p style="text-align: center"><inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>L</mi>
    <mi>B</mi>
    <mo>=</mo>
    <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
    <mo>=</mo>
    <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">{</mo>
      <mo>,</mo>
      <mo data-mjx-texclass="CLOSE">}</mo>
      <mi>L</mi>
      <mi>L</mi>
      <msub>
        <mi>B</mi>
        <mn>1</mn>
      </msub>
      <msub>
        <mi>B</mi>
        <mn>2</mn>
      </msub>
    </mrow>
    <mrow data-mjx-texclass="INNER">
      <mo data-mjx-texclass="OPEN">{</mo>
      <mo>+</mo>
      <mo>⋅</mo>
      <mo>+</mo>
      <mo>+</mo>
      <mo>+</mo>
      <mo>,</mo>
      <mo>+</mo>
      <mo>+</mo>
      <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
      <mo>+</mo>
      <mo>+</mo>
      <mo>⋅</mo>
      <mo data-mjx-texclass="CLOSE">}</mo>
      <msub>
        <mi>r</mi>
        <mrow data-mjx-texclass="ORD">
          <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
        </mrow>
      </msub>
      <msub>
        <mi>p</mi>
        <mi>i</mi>
      </msub>
      <msub>
        <mi>r</mi>
        <mrow data-mjx-texclass="ORD">
          <mo data-mjx-texclass="OP" movablelimits="true">min</mo>
        </mrow>
      </msub>
      <mrow data-mjx-texclass="INNER">
        <mo data-mjx-texclass="OPEN">⌈</mo>
        <mo data-mjx-texclass="CLOSE">⌉</mo>
        <msub>
          <mi>s</mi>
          <mi>i</mi>
        </msub>
        <mrow data-mjx-texclass="ORD">
          <mo>/</mo>
        </mrow>
        <mi>c</mi>
      </mrow>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mi>n</mi>
        <mo>=</mo>
        <mo>,</mo>
        <mo>,</mo>
        <mo>…</mo>
        <mo>,</mo>
        <mn>1</mn>
        <mn>2</mn>
      </mrow>
      <mrow data-mjx-texclass="INNER">
        <mo data-mjx-texclass="OPEN">{</mo>
        <mo data-mjx-texclass="CLOSE">}</mo>
        <mi>p</mi>
        <mi>i</mi>
      </mrow>
      <mrow data-mjx-texclass="INNER">
        <mo data-mjx-texclass="OPEN">⌈</mo>
        <mo data-mjx-texclass="CLOSE">⌉</mo>
        <msub>
          <mi>s</mi>
          <mi>i</mi>
        </msub>
        <mrow data-mjx-texclass="ORD">
          <mo>/</mo>
        </mrow>
        <mi>c</mi>
      </mrow>
      <mi>s</mi>
      <mi>T</mi>
      <mi>P</mi>
      <mi>s</mi>
      <mi>T</mi>
      <mi>P</mi>
      <munderover>
        <mo data-mjx-texclass="OP">∑</mo>
        <mrow data-mjx-texclass="ORD">
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
        <mi>n</mi>
      </munderover>
    </mrow>
  </math>
</inline-formula></p>
    </sec>
    <sec disp-level="level1" sec-type="">
      <title>5. Simulation demonstration and analysis</title>
      <p>In order to test the performance of the two-stage algorithm TS-A, the analysis is carried out through simulation experiments. In the simulation experiment, the number of wounded and the time to arrive at the triage field are represented by discrete values and interval values respectively, such as the number of wounded, <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>n</mi>
    <mo>∈</mo>
  </math>
</inline-formula>{300,500,700,1000,1500,2000} and the time <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub>
      <mi>r</mi>
      <mi>i</mi>
    </msub>
    <mo>∈</mo>
  </math>
</inline-formula>[1,200] when the wounded arrive at the triage field, i=1,2,...,n. In the same way, the triage capacity of the triage team or the transport capacity of the transport vehicle <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>c</mi>
    <mo>∈</mo>
  </math>
</inline-formula>{150,280} in the triage field, the count value of the wounded <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub>
      <mi>s</mi>
      <mi>i</mi>
    </msub>
    <mo>∈</mo>
  </math>
</inline-formula>[1, n], i=1,2,...,n, the triage time of the wounded <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub>
      <mi>p</mi>
      <mi>i</mi>
    </msub>
    <mo>∈</mo>
  </math>
</inline-formula>[1,20], the waiting time of the wounded in the triage field is <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>s</mi>
    <mo>∈</mo>
  </math>
</inline-formula>[0,20], the transfer time of the wounded between the triage field and the hospital is <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>T</mi>
    <mo>∈</mo>
  </math>
</inline-formula>[30, 80], and the operation time of the wounded in the operating room of the hospital is <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>P</mi>
    <mo>∈</mo>
  </math>
</inline-formula>[45,130].</p><p>In order to evaluate the performance of the algorithm, the TS-A algorithm is compared with the MFF algorithm and the MBF algorithm [<xref ref-type="bibr" rid="ref_9">9</xref>]. The relative gap between the maximum time span of the whole rescue process obtained by the two-stage algorithm TS-A and the optimal performance under ideal conditions (the maximum of the two lower bounds) can be used to measure the performance of the algorithm. The relative gap percentage is as follows:</p><p style="text-align: center"><inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>R</mi>
    <mi>G</mi>
    <mi mathvariant="normal">%</mi>
    <mo>=</mo>
    <mo>⋅</mo>
    <mfrac>
      <mrow>
        <msub>
          <mi>C</mi>
          <mrow data-mjx-texclass="ORD">
            <mover>
              <mo data-mjx-texclass="OP" movablelimits="true">max</mo>
              <mi>H</mi>
            </mover>
          </mrow>
        </msub>
        <mo>−</mo>
        <mi>L</mi>
        <mi>B</mi>
      </mrow>
      <mrow>
        <mi>L</mi>
        <mi>B</mi>
      </mrow>
    </mfrac>
    <mn>100</mn>
  </math>
</inline-formula></p><p>Considering the factors that usually vary in simulation experiments, the number of wounded and the number of wounded triaged in each batch or the capacity of rescue vehicles can be used as experimental factors, and the performance of the algorithm is tested with and variables <italic>n</italic> and <italic>c</italic>. <italic>n</italic> represents the number of wounded, <italic>c</italic> represents the capacity of each batch for triage or the carrying capacity of the vehicle, repeat the experiments for ten times with the values of <italic>n</italic> and <italic>c.</italic></p><p>Because <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>c</mi>
    <mo>∈</mo>
    <mo fence="false" stretchy="false">{</mo>
    <mo>,</mo>
    <mo fence="false" stretchy="false">}</mo>
    <mn>150</mn>
    <mn>280</mn>
  </math>
</inline-formula> and <inline-formula>
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>n</mi>
    <mo>∈</mo>
    <mo fence="false" stretchy="false">{</mo>
    <mo>,</mo>
    <mo>,</mo>
    <mo>,</mo>
    <mo>,</mo>
    <mo>,</mo>
    <mo fence="false" stretchy="false">}</mo>
    <mn>300</mn>
    <mn>500</mn>
    <mn>700</mn>
    <mn>1000</mn>
    <mn>1500</mn>
    <mn>2000</mn>
  </math>
</inline-formula>, the experiment is divided into two cases: <italic>c</italic>=150 and <italic>c</italic>=280.</p><p>(1) When <italic>c</italic>=150, after 10 repeated experiments, the average value of <italic>RG</italic> obtained is shown in <xref ref-type="fig" rid="fig_2">Figure 2</xref>.</p><p>It can be seen from the figure that when the number of wounded increases, the average value of <italic>RG</italic> calculated by the TS-A algorithm decreases. When the number of wounded ranges from 300 to 2000, the average value of <italic>RG</italic> ranges from 0.75% to 3.23%. It shows that when the capacity of each batch of triage or the carrying capacity of the transport vehicle is 150, as the number of wounded increases, the performance of the algorithm is closer to the optimal performance under ideal conditions. The experimental results also show that the TS-A algorithm has better performance than the MFF algorithm and MBF algorithm.</p>
      
        <fig id="fig_2">
          <label>Figure 2</label>
          <caption>The experimental results of the average gap percentage when c=150</caption>
          <abstract/>
          <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2023/2/img_zvLDjfZBf3cvHoUM.png"/>
        </fig>
      
      <p>(2) When<italic> c</italic>=280, after 10 repeated experiments, the average value of <italic>RG</italic> obtained is shown in <xref ref-type="fig" rid="fig_3">Figure 3</xref>.</p><p>It can be seen from the figure that when the number of wounded increases, the average value of <italic>RG</italic> calculated by the TS-A algorithm decreases. When the number of wounded ranges from 300 to 2,000, the average value of <italic>RG</italic> ranges from 0.23% to 2.94%. It shows that when the capacity of each batch of triage or the carrying capacity of the transport vehicle is 280, as the number of wounded increases, the performance of the algorithm is closer to the optimal performance under ideal conditions. The experimental results also show that the TS-A algorithm has better performance than the MFF algorithm and MBF algorithm.</p>
      
        <fig id="fig_3">
          <label>Figure 3</label>
          <caption>The experimental results of the average gap percentage when c=280</caption>
          <abstract/>
          <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2023/2/img_4A4S35NuqPgzCq5q.png"/>
        </fig>
      
      <p>Similarly, when the capacity of each batch of triage or the carrying capacity of the transport vehicle increases, the average gap percentage also decreases, indicating that the increase in the capacity of each batch of triage or the carrying capacity of the transport vehicle will improve the performance of the algorithm. The above two graphs show that the TS-A algorithm proposed herein has a better solution and better performance for the situation where the number of wounded is larger and the carrying capacity is stronger.</p>
    </sec>
    <sec disp-level="level1" sec-type="conclusions">
      <title>6. Conclusions</title>
      <p>For the wounded triage, transport and cooperative scheduling problem of emergency surgery in urban emergency rescue, this study adopts a supply chain-like processing method to realize the collaborative scheduling of each rescue link. It mainly considers the collaborative scheduling problem of triage, transport and surgery under the constraint factors such as the different time when the wounded arrive at the triage field and the different transport capacity of the transport vehicles. The research goal is to minimize the whole rescue time span of different batches of wounded in the rescue process; it establishes a mathematical model to arrange batches of wounded according to the capacity of the triage field or the transport capacity of the transport vehicle, analyzes the impact of batches on the whole process time, and gives the nature of the problem in general and special cases.</p><p>In order to evaluate the performance of the TS-A algorithm, this study finally gives a two-stage algorithm TS-A and constructs the lower bound of the problem domain under the ideal state. The simulation experiment shows that the TS-A algorithm proposed herein is superior to the other two algorithms mentioned in references. At the same time, for the case of a large number of wounded and a large rescue vehicle capacity, the experiment can obtain better results, which shows that the algorithm can handle large-scale collaborative scheduling problems.</p>
    </sec>
  </body>
  <back>
    <ack>
      <title>Acknowledgments</title>
      
    </ack>
    <app-group>
      <app>
        <title>Appendix</title>
        
      </app>
    </app-group>
    <notes>
      <title>Author Contributions</title>
      
    </notes>
    <notes>
      <title>Funding</title>
      <p>Ministry of Education Humanities and Social Sciences Research Youth Fund Project (Grant No.: 18YJCZH216); Doctoral Research Fund of Henan University of Chinese Medicine (Grant No.: BSJJ2020-11); Philosophy and Social Sciences Planning Project of Henan Province (Grant No.: 2021BZH009); Henan Province Key R&amp;D and Promotion Special Project (Soft Science Research) Project Funding (Grant No.: 222400410477).</p>
    </notes>
    <notes>
      <title>Informed Consent Statement</title>
      
    </notes>
    <notes>
      <title>Data Availability Statement</title>
      <p>The data used to support the findings of this study are available from the corresponding author upon request.</p>
    </notes>
    <notes notes-type="COI-statement">
      <title>Conflicts of Interest</title>
      <p>The authors declare that they have no conflicts of interest.</p>
    </notes>
    <ref-list>
      <title>References</title>
      <ref id="ref_1">
        <label>1.</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <given-names>C. H.</given-names>
              <surname>Liu</surname>
            </name>
          </person-group>
          <article-title>Using genetic algorithms for the coordinated scheduling problem of a batching machine and two-stage transportation</article-title>
          <source>Appl Math. Comput.</source>
          <year>2011</year>
          <volume>217</volume>
          <issue>4</issue>
          <page-range>10095-10104</page-range>
          <fpage>10095</fpage>
          <lpage>10104</lpage>
          <pub-id pub-id-type="doi">https://doi.org/10.1016/j.amc.2011.05.005</pub-id>
          <pub-id pub-id-type="publisher-id"/>
        </element-citation>
      </ref>
      <ref id="ref_2">
        <label>2.</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <given-names>J. M.</given-names>
              <surname>Garcia</surname>
            </name>
            <name>
              <given-names>S.</given-names>
              <surname>Lozano</surname>
            </name>
          </person-group>
          <article-title>Production and delivery scheduling problem with time windows</article-title>
          <source>Comput. Ind Eng.</source>
          <year>2005</year>
          <volume>48</volume>
          <issue>4</issue>
          <page-range>733-742</page-range>
          <fpage>733</fpage>
          <lpage>742</lpage>
          <pub-id pub-id-type="doi">https://doi.org/10.1016/j.cie.2004.12.004</pub-id>
          <pub-id pub-id-type="publisher-id"/>
        </element-citation>
      </ref>
      <ref id="ref_3">
        <label>3.</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <given-names>L.</given-names>
              <surname>Niu</surname>
            </name>
            <name>
              <given-names>X. T.</given-names>
              <surname>Han</surname>
            </name>
          </person-group>
          <article-title>Research on manufacturing cell collaborative scheduling algorithm based on two-stage scheduling</article-title>
          <source>Comput. Eng. Appl.</source>
          <year>2013</year>
          <volume>2013</volume>
          <issue>9</issue>
          <page-range>232-237</page-range>
          <fpage>232</fpage>
          <lpage>237</lpage>
          <pub-id pub-id-type="doi"/>
          <pub-id pub-id-type="publisher-id"/>
        </element-citation>
      </ref>
      <ref id="ref_4">
        <label>4.</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <given-names>J. L.</given-names>
              <surname>Hu</surname>
            </name>
            <name>
              <given-names>H. F.</given-names>
              <surname>Li</surname>
            </name>
            <name>
              <given-names>J. M.</given-names>
              <surname>Dong</surname>
            </name>
            <name>
              <given-names>Y. W.</given-names>
              <surname>Jiang</surname>
            </name>
          </person-group>
          <article-title>Single-machine scheduling problem considering coordinated processing and transportation scheduling</article-title>
          <source>J. Ind Eng. Eng Manage.</source>
          <year>2013</year>
          <volume>27</volume>
          <issue>1</issue>
          <page-range>166-170</page-range>
          <fpage>166</fpage>
          <lpage>170</lpage>
          <pub-id pub-id-type="doi"/>
          <pub-id pub-id-type="publisher-id"/>
        </element-citation>
      </ref>
      <ref id="ref_5">
        <label>5.</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <given-names>C. T.</given-names>
              <surname>Ng</surname>
            </name>
            <name>
              <given-names>T. C. E.</given-names>
              <surname>Cheng</surname>
            </name>
            <name>
              <given-names>J. J.</given-names>
              <surname>Yuan</surname>
            </name>
            <name>
              <given-names>Z. H.</given-names>
              <surname>Liu</surname>
            </name>
          </person-group>
          <article-title>On the single machine serial batching scheduling problem to minimize total completion time with precedence constraints, release dates and identical processing times</article-title>
          <source>Oper. Res. Lett.</source>
          <year>2013</year>
          <volume>31</volume>
          <issue>4</issue>
          <page-range>323-326</page-range>
          <fpage>323</fpage>
          <lpage>326</lpage>
          <pub-id pub-id-type="doi">https://doi.org/10.1016/S0167-6377(03)00007-5</pub-id>
          <pub-id pub-id-type="publisher-id"/>
        </element-citation>
      </ref>
      <ref id="ref_6">
        <label>6.</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <given-names>L. L.</given-names>
              <surname>Liu</surname>
            </name>
            <name>
              <given-names>C. T.</given-names>
              <surname>Ng</surname>
            </name>
            <name>
              <given-names>T. C. E.</given-names>
              <surname>Cheng</surname>
            </name>
          </person-group>
          <article-title>On scheduling unbounded batch processing machine(s)</article-title>
          <source>Comput. Ind Eng.</source>
          <year>2010</year>
          <volume>58</volume>
          <issue>4</issue>
          <page-range>814-817</page-range>
          <fpage>814</fpage>
          <lpage>817</lpage>
          <pub-id pub-id-type="doi">https://doi.org/10.1016/j.cie.2010.02.003</pub-id>
          <pub-id pub-id-type="publisher-id"/>
        </element-citation>
      </ref>
      <ref id="ref_7">
        <label>7.</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <given-names>W. P.</given-names>
              <surname>Wang</surname>
            </name>
            <name>
              <given-names>X. Y.</given-names>
              <surname>Yu</surname>
            </name>
          </person-group>
          <article-title>MILP model for resource-constrained parallel processor scheduling</article-title>
          <source>Microcomput. Inf.</source>
          <year>2006</year>
          <volume>22</volume>
          <issue>7</issue>
          <page-range>267-268</page-range>
          <fpage>267</fpage>
          <lpage>268</lpage>
          <pub-id pub-id-type="doi"/>
          <pub-id pub-id-type="publisher-id"/>
        </element-citation>
      </ref>
      <ref id="ref_8">
        <label>8.</label>
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <given-names>D.</given-names>
              <surname>Simchi-Levi</surname>
            </name>
          </person-group>
          <article-title>New worst-case results for the bin-packing problem</article-title>
          <source>Nav Res. Logist.</source>
          <year>1994</year>
          <volume>41</volume>
          <issue>4</issue>
          <page-range>579-585</page-range>
          <fpage>579</fpage>
          <lpage>585</lpage>
          <pub-id pub-id-type="doi">https://doi.org/10.1002/1520-6750(199406)41:4%3C579::AID-NAV3220410409%3E3.0.CO;2-G</pub-id>
          <pub-id pub-id-type="publisher-id"/>
        </element-citation>
      </ref>
      <ref id="ref_9">
        <label>9.</label>
        <element-citation publication-type="thesis">
          <person-group person-group-type="author">
            <name>
              <given-names>M.</given-names>
              <surname>Cesar</surname>
            </name>
            <name>
              <given-names>V.</given-names>
              <surname>Gallego</surname>
            </name>
          </person-group>
          <article-title>Algorithms for scheduling parallel batch processing machines with non-identical job ready times</article-title>
          <source>Doctoral Dissertation</source>
          <year>2009</year>
          <publisher-name>Florida International University</publisher-name>
          <publisher-loc>USA</publisher-loc>
        </element-citation>
      </ref>
    </ref-list>
  </back>
</article>