<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.3 20210610//EN" "JATS-journalpublishing1-3.dtd">
<article xml:lang="en" dtd-version="1.3" article-type="research-article" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <front>
    <journal-meta>
      <journal-id journal-id-type="publisher-id">JIMD</journal-id>
      <journal-id journal-id-type="doi">10.56578</journal-id>
      <journal-title-group>
        <journal-title>Journal of Intelligent Management Decision</journal-title>
        <abbrev-journal-title abbrev-type="issn">J. Intell. Manag. Decis.</abbrev-journal-title>
        <abbrev-journal-title abbrev-type="publisher">JIMD</abbrev-journal-title>
      </journal-title-group>
      <issn publication-format="electronic">2958-0080</issn>
      <issn publication-format="print">2958-0072</issn>
      <publisher>
        <publisher-name>Acadlore</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="publisher-id">AR-BbFdl6fAKqC2qN1ODyCY78AJF3o-h3S9</article-id>
      <article-id pub-id-type="doi">10.56578/jimd030304</article-id>
      <article-categories>
        <subj-group>
          <subject>Articles</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Security-Enhanced QoS-Aware Autoscaling of Kubernetes Pods Using Horizontal Pod Autoscaler (HPA)</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author" rid="aff_1">
          <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0003-1851-6526</contrib-id>
          <name>
            <surname>Rajasekar</surname>
            <given-names>Vani</given-names>
          </name>
          <email>vanikecit@gmail.com</email>
        </contrib>
        <contrib contrib-type="author" rid="aff_2">
          <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0003-2577-7927</contrib-id>
          <name>
            <surname>SaračEvić</surname>
            <given-names>Muzafer</given-names>
          </name>
          <email>muzafers@uninp.edu.rs</email>
        </contrib>
        <contrib contrib-type="author" rid="aff_3">
          <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0001-5308-2503</contrib-id>
          <name>
            <surname>KarabašEvić</surname>
            <given-names>Darjan</given-names>
          </name>
          <email>darjan.karabasevic@mef.edu.rs</email>
        </contrib>
        <contrib contrib-type="author" rid="aff_4">
          <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0002-6846-3074</contrib-id>
          <name>
            <surname>Stanujkić</surname>
            <given-names>DragišA</given-names>
          </name>
          <email>dstanujkic@tfbor.bg.ac.rs</email>
        </contrib>
        <contrib contrib-type="author" rid="aff_2">
          <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0003-2296-8728</contrib-id>
          <name>
            <surname>Hasić</surname>
            <given-names>Amor</given-names>
          </name>
          <email>amorhasic@gmail.com</email>
        </contrib>
        <contrib contrib-type="author" rid="aff_2">
          <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0002-6969-5133</contrib-id>
          <name>
            <surname>Azizović</surname>
            <given-names>Melisa</given-names>
          </name>
          <email>melisa.azizovic@gmail.com</email>
        </contrib>
        <contrib contrib-type="author" rid="aff_1">
          <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0009-0000-7394-8730</contrib-id>
          <name>
            <surname>Thirumalai</surname>
            <given-names>Srivarshan</given-names>
          </name>
          <email>srivarshant2002@gmail.com</email>
        </contrib>
        <aff id="aff_1">Kongu Engineering College, Thoppupalayam, Kumaran Nagar, 638060 Tamil Nadu, India</aff>
        <aff id="aff_2">Department of Computer Sciences, University of Novi Pazar, 36300 Novi Pazar, Serbia</aff>
        <aff id="aff_3">Faculty of Applied Management, Economics and Finance, University Business Academy in Novi Sad, 11000 Belgrade, Serbia</aff>
        <aff id="aff_4">Technical Faculty in Bor, University of Belgrade, 19210 Bor, Serbia</aff>
      </contrib-group>
      <pub-date publication-format="electronic" date-type="pub">
        <day>24</day>
        <month>09</month>
        <year>2024</year>
      </pub-date>
      <volume>3</volume>
      <issue>3</issue>
      <fpage>175</fpage>
      <lpage>186</lpage>
      <page-range>175-186</page-range>
      <history>
        <date date-type="received">
          <day>01</day>
          <month>08</month>
          <year>2024</year>
        </date>
        <date date-type="accepted">
          <day>19</day>
          <month>09</month>
          <year>2024</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>©2024 by the author(s)</copyright-statement>
        <copyright-year>2024</copyright-year>
        <license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
          <license-p> Published by Acadlore Publishing Services Limited, Hong Kong. This article is available for free download and can be reused and cited, provided that the original published version is credited, under the CC BY 4.0 license.</license-p>
        </license>
      </permissions>
      <abstract><p>Container-based virtualization has emerged as a leading alternative to traditional cloud-based architectures due to its lower overhead, enhanced scalability, and adaptability. Kubernetes, one of the most widely adopted open-source container orchestration platforms, facilitates dynamic resource allocation through the Horizontal Pod Autoscaler (HPA). This auto-scaling mechanism enables efficient deployment and management of microservices, allowing for rapid development of complex SaaS applications. However, recent studies have identified several vulnerabilities in auto-scaling systems, including brute force attacks, Denial-of-Service (DoS) attacks, and YOYO attacks, which have led to significant performance degradation and unexpected downtimes. In response to these challenges, a novel approach is proposed to ensure uninterrupted deployment and enhanced resilience against such attacks. By leveraging Helm for deployment automation, Prometheus for metrics collection, and Grafana for real-time monitoring and visualisation, this framework improves the Quality of Service (QoS) in Kubernetes clusters. A primary focus is placed on achieving optimal resource utilisation while meeting Service Level Objectives (SLOs). The proposed architecture dynamically scales workloads in response to fluctuating demands and strengthens security against autoscaling-specific attacks. An on-premises implementation using Kubernetes and Docker containers demonstrates the feasibility of this approach by mitigating performance bottlenecks and preventing downtime. The contribution of this research lies in the ability to enhance system robustness and maintain service reliability under malicious conditions without compromising resource efficiency. This methodology ensures seamless scalability and secure operations, making it suitable for enterprise-level microservices and cloud-native applications.</p></abstract>
      <kwd-group>
        <kwd>Kubernetes</kwd>
        <kwd>Quality of Service (QoS)</kwd>
        <kwd>Horizontal Pod Autoscaler (HPA)</kwd>
        <kwd>Attacks</kwd>
        <kwd>Data protection</kwd>
      </kwd-group>
      <counts>
        <count count-type="contributors" count="7"/>
        <fig-count count="5"/>
        <table-count count="0"/>
        <ref-count count="23"/>
      </counts>
    </article-meta>
  </front>
  <body>
    <sec sec-type="intro">
      <title>1. Introduction</title>
      <p>Cloud computing has become incredibly popular in recent years. Companies are deploying premises networks and public clouds in greater numbers. Online services are used for most real-time applications, including banking, education, and health care. These services are crucial for the same models that are set up in clouds [<xref ref-type="bibr" rid="ref_1">1</xref>]. The resource provision feature of cloud computing, which provides quick elasticity and dynamic scalability, is one of its key benefits. Scaling pods is by default based solely on CPU utilization, a single performance parameter. The proposed methodology for achieving the scenario involves the use of several tools that work together seamlessly. Docker is a popular tool that is used for containerization, which refers to the process of packaging an application along with its dependencies and configuration files into a single unit known as a container. With Docker, it is possible to create a Docker image that contains all the necessary components for running an application. These images can then be used to create Docker containers that can be run on any machine that has Docker installed. Kubernetes, on the other hand, provides a platform for managing and deploying containerized applications. It enables users to automate the deployment, scaling, and management of containerized applications. By using Kubernetes, it is possible to deploy a containerized application across multiple nodes, making it easier to manage and scale [<xref ref-type="bibr" rid="ref_2">2</xref>], [<xref ref-type="bibr" rid="ref_3">3</xref>]. Helm is a package manager for Kubernetes that enables users to easily deploy and manage applications on a Kubernetes cluster. It provides a simple way to define, install, and upgrade Kubernetes applications. Prometheus is an open-source monitoring system that is used to collect metrics from various sources. It is widely used for monitoring Kubernetes clusters, and it is capable of collecting metrics from various components of the cluster, including nodes, pods, and containers. IaaS clouds have on-demand scaling capabilities. Scalability, however, is a challenge in SaaS setups. To increase service quality, existing programs must reside together with new apps and services. Businesses today need a mobile and interoperable environment that can scale and adapt to user needs to incorporate all these constraints into the systems. A pod is guaranteed to receive a minimum amount of CPU time for each request in Kubernetes [<xref ref-type="bibr" rid="ref_4">4</xref>]. HPA automatically scales copies of pods based on observed CPU utilization by default.</p><p>The application may crash if it experiences stress and the number of incoming requests exceeds the pod's capacity. To prevent this, Kubernetes implements pod auto-scaling, which can be monitored by Grafana and managed through alerts from Prometheus. Before deploying the application in the EKS cluster, the proposed approach first sets up all essential services to establish the required infrastructure. Helm coordinates the deployment, service management, and horizontal auto-scaling within the Kubernetes cluster. Prometheus is installed in the cluster to collect data about the environment where the application runs. This data is then visualized on an interactive dashboard in Grafana, which displays alerts and other relevant information.</p><p>The Elastic Kubernetes Service (EKS) is provisioned in Amazon Web Services (AWS), and the Docker image is deployed into the EKS cluster using Helm. HPA in Kubernetes facilitates pod auto-scaling during periods of high demand or upgrades. <xref ref-type="fig" rid="fig_1">Figure 1</xref> illustrates the application deployment along with the necessary AWS infrastructure, which includes services such as AWS EC2, EKS, Relational Database Service (RDS), node groups, auto-scaling groups, security groups, and Virtual Private Cloud (VPC).</p>
      
        <fig id="fig_1">
          <label>Figure 1</label>
          <caption>
            <title>The flow of the proposed methodology</title>
          </caption>
          <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_no8gh00wygPXAlO9.png"/>
        </fig>
      
      <p>The cloud VMs' autoscaling system is the target of the attacks. The auto-scaling mechanism swings between scale-up and scale-down phases as a result of the recurring spikes in traffic volumes. Along with causing financial harm, the attacks significantly reduce performance. The cloud service experiences a significant performance hit throughout the recurrent scale-up process, which typically lasts up to a few minutes. The attacker stops transmitting traffic when the scale-up procedure is complete and waits for the scale-down process to begin. The attacker launches another attack after the scale-down phase is finished, and so on [<xref ref-type="bibr" rid="ref_5">5</xref>], [<xref ref-type="bibr" rid="ref_6">6</xref>], [<xref ref-type="bibr" rid="ref_7">7</xref>], [<xref ref-type="bibr" rid="ref_8">8</xref>]. Additionally, there are more machines after the scale-up process but fewer users. As a result, the victim unknowingly pays for extra, unused equipment.</p><p>While resource saturation may lead to SLO breaches, the precise association has not yet been formally established. This is an important aspect to keep in mind. A perfect autoscaling system should respond immediately to changes in application-level metrics, such as rising SLO violation rates. Designing and implementing a monitoring system that keeps track of and combines monitoring information from resources in data centers and microservices is a difficult task. Using this data, the QoS service implements rules and takes action to ensure that the SLOs for resource utilization are met. To overcome the aforementioned issue, the proposed method suggests enhancing the Kubernetes cluster autoscaler with unique rules based on the state-of-the-art existing methodology. This study provides a multi-tier architecture with a monitoring system and QoS services to measure the workload and usage of resources across all tiers and layers and to constantly adjust to satisfy QoS and SLO requirements.</p><p>The major contributions of the proposed approach are:</p><p>$~<inline-formula>
  <mml:math id="m5g2pxf4ar">
    <mml:mo>&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;</mml:mo>
    <mml:mo>·</mml:mo>
    <mml:mo>&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;</mml:mo>
    <mml:mo>−</mml:mo>
    <mml:mo>.</mml:mo>
    <mml:mo>&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;</mml:mo>
    <mml:mi>s</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>I</mml:mi>
    <mml:mi>m</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mi>l</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>m</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>f</mml:mi>
    <mml:mi>K</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>b</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>l</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>v</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>m</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>A</mml:mi>
    <mml:mi>W</mml:mi>
    <mml:mi>S</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>l</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>d</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>f</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mrow>
      <mml:mo>/</mml:mo>
    </mml:mrow>
    <mml:mrow>
      <mml:mo>/</mml:mo>
    </mml:mrow>
  </mml:math>
</inline-formula>~<inline-formula>
  <mml:math id="mtv9ce5r3e">
    <mml:mo>&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;</mml:mo>
    <mml:mo>·</mml:mo>
    <mml:mo>&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;</mml:mo>
    <mml:mo>−</mml:mo>
    <mml:mo>−</mml:mo>
    <mml:mo>.</mml:mo>
    <mml:mo>&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;</mml:mo>
    <mml:mi>s</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>D</mml:mi>
    <mml:mi>y</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>m</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>l</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>f</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>d</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>H</mml:mi>
    <mml:mi>P</mml:mi>
    <mml:mi>A</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>m</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>h</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>S</mml:mi>
    <mml:mi>L</mml:mi>
    <mml:mi>A</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>q</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>m</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>l</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>d</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>l</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>d</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>w</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mrow>
      <mml:mo>/</mml:mo>
    </mml:mrow>
    <mml:mrow>
      <mml:mo>/</mml:mo>
    </mml:mrow>
  </mml:math>
</inline-formula>~<inline-formula>
  <mml:math id="m3cr8w4vo0">
    <mml:mo>&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;</mml:mo>
    <mml:mo>·</mml:mo>
    <mml:mo>&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;</mml:mo>
    <mml:mo>.</mml:mo>
    <mml:mo>&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;&amp;lt;</mml:mo>
    <mml:mo>&amp;gt;</mml:mo>
    <mml:mi>s</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>D</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>f</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>k</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>d</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>m</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>h</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>h</mml:mi>
    <mml:mi>c</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>m</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>t</mml:mi>
    <mml:mi>o</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>u</mml:mi>
    <mml:mi>s</mml:mi>
    <mml:mi>i</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>g</mml:mi>
    <mml:mi>H</mml:mi>
    <mml:mi>e</mml:mi>
    <mml:mi>l</mml:mi>
    <mml:mi>m</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>d</mml:mi>
    <mml:mi>G</mml:mi>
    <mml:mi>r</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>f</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>n</mml:mi>
    <mml:mi>a</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mi>p</mml:mi>
    <mml:mrow>
      <mml:mo>/</mml:mo>
    </mml:mrow>
    <mml:mrow>
      <mml:mo>/</mml:mo>
    </mml:mrow>
  </mml:math>
</inline-formula>~$ · Ensuring the better SLO requirement for improved resource usage and guaranteed QoS.</p>
    </sec>
    <sec sec-type="">
      <title>2. Literature review</title>
      <p>In software architecture, virtual machines are a crucial intermediate layer. The advantages of containers over virtual machines have been the subject of extensive research due to the growing popularity of container-based virtualization solutions. Containers provide advantages for Platform-as-a-Service (PaaS) clouds because of their simplicity in application management, deployment, and setup. Zhu et al. [<xref ref-type="bibr" rid="ref_9">9</xref>] suggest a bi-metric strategy for scaling pods that accounts for both CPU usage and thread pool usage, which is a type of significant soft resource in HTTPD and Tomcat. Our method measures how much each pod's CPU and memory are being used. In the meantime, it uses ELBA, a milli-bottleneck detector, to determine the queue lengths of the Httpd and Tomcat pods and then assess how well their thread pools are being used. Container orchestration has huge potential to advance distributed cloud services and network management. A series of experiments were conducted to demonstrate the improvement of containers over virtual machines with performance evaluations. Ruíz et al. [<xref ref-type="bibr" rid="ref_10">10</xref>] describe a Kubernetes and Docker-based on-premise architecture that aims to enhance the QoS in terms of resource use and SLOs. Their primary contribution is their ability to dynamically autoscale the resources to match the present workload while enhancing QoS. Orchestration will be a beneficial addition to the design because it will automate the behavior required to achieve reliability and responsiveness. To properly match the orchestrator's operations with the platform's SLOs, however, it might be necessary to specify unique orchestration rules. Developing a unique monitoring service and enhancing the QoS service will be essential.</p><p>The current Kubernetes resource allocation policy for application instances cannot dynamically modify following business requirements, resulting in significant resource waste during fluctuations. Additionally, the introduction of new cloud services has increased the need for resource management. The adaptive horizontal pod auto-scaling system (AHPA), a recently implemented AI algorithm framework, is used in this study to examine the management of horizontal POD resources in Alibaba Cloud Container Services. AHPA presents an ideal pod number adjustment strategy that could reduce POD resources and keep company stability based on a reliable decomposition forecasting algorithm and performance training model [<xref ref-type="bibr" rid="ref_11">11</xref>], [<xref ref-type="bibr" rid="ref_12">12</xref>], [<xref ref-type="bibr" rid="ref_13">13</xref>]. With the advancement of cloud computing technologies, more and more businesses are adopting and promoting the Kubernetes-led container management architecture. With the help of one of its features, Autoscaling, clients' dynamic requirements can be handled automatically. Although it appears that K8s' autoscaling solution is adequate, the majority of scaling solutions, including HPA, are based on reactive autoscaling, which uses CPU or memory utilization as a metric. To obtain or allocate computing resources on request, autoscaling is an important notion of cloud infrastructure. It enables users to automatically scale the resources provided to applications under fluctuating workloads to reduce resource costs while meeting QoS demands.</p><p>The widely used popular container orchestration system, Kubernetes, contains built-in autoscalers to address the autoscaling issues at the container level for both horizontal and vertical scaling, although it still has significant restrictions. Because of a predetermined number of resources for each instance, only horizontal scalability may result in low container utilization, especially during periods of low demand. In contrast, if the workload spikes owing to hitting the upper limit, just vertical scaling might not be able to maintain the required QoS. In addition, to ensure service performance, burst identification for auto-scalers is also required [<xref ref-type="bibr" rid="ref_14">14</xref>], [<xref ref-type="bibr" rid="ref_15">15</xref>]. Microservices have been acknowledged by the cloud community as the leading architecture for putting cloud-native applications into practice. Application owners must carefully scale the necessary resources to effectively run microservice-based applications while taking into account the fluctuating workload of each of the microservices. The difficulty of resource supply for these applications emphasizes how important autoscaling methods are [<xref ref-type="bibr" rid="ref_16">16</xref>], [<xref ref-type="bibr" rid="ref_17">17</xref>]. Dogani et al. [<xref ref-type="bibr" rid="ref_18">18</xref>] suggest a multi-objective autoscaling approach to prevent resource waste and achieve the required average response time of microservices. They provide a toolchain for microservices in autoscaling with hybrid nature in Kubernetes based on machine learning (ML) approaches. They also suggested the best model for resolving the issue after comparing various ML approaches and our performance modeling tool, termed Extra-P. A thorough analysis of a benchmark component demonstrates a considerable decrease in resource utilization while still matching the user-specified average response time, outperforming the outcomes of the standard HPA in Kubernetes.</p><p>The timely management of virtualized resources is necessary to maximize the performance of contemporary applications. However, it can be very difficult to deploy resources proactively to satisfy specific application requirements when there is a fluctuating workload from incoming requests. To do this, it is necessary to jointly solve the basic issues with task scheduling and resource autoscaling [<xref ref-type="bibr" rid="ref_19">19</xref>]. To address both, a scalable design that is compatible with Kubernetes' decentralized structure is described in previous studies [<xref ref-type="bibr" rid="ref_10">10</xref>], [<xref ref-type="bibr" rid="ref_20">20</xref>], [<xref ref-type="bibr" rid="ref_21">21</xref>], [<xref ref-type="bibr" rid="ref_22">22</xref>], [<xref ref-type="bibr" rid="ref_23">23</xref>]. They dynamically reroute requests that arrive at the containerized application by utilizing the stability guarantees of a unique Additive Increase Multiplicative Decrease (AIMD)-like task scheduling mechanism. A prediction method enables us to predict the number of incoming requests to handle fluctuating workloads. The scaling issue is also addressed by introducing ML-based application profiling modeling that integrates the theoretically computed service rates acquired from the AIMD technique with the existing performance measurements. The remainder of the paper is organized in such a way that Section 3 describes the proposed methodology, which describes the AWS services, Grafana, Prometheus, and Helm. The deployment strategy is also explained with the EKS cluster in Kubernetes. Section 4 discusses the results and evaluation, where the HPA is demonstrated along with the CPU usage analysis. Section 5 discusses the conclusion of the proposed work, and future enhancements concerning the proposed methodology are also given.</p>
    </sec>
    <sec sec-type="">
      <title>3. Proposed methodology</title>
      
        <sec>
          
            <title>3.1. Preliminaries</title>
          
          <p>The architecture necessary for deploying the application on AWS is illustrated in <xref ref-type="fig" rid="fig_2">Figure 2</xref>. A VPC is set up in AWS to host the required services. An Internet Gateway (IG) is established to enable external access to these services. For database needs, AWS RDS is utilized. Amazon EKS manages the deployment orchestration for the application within AWS. Once the EKS cluster is deployed, a node group is created using AWS EC2, which serves as the cloud computing platform for application deployment. Security responsibilities are shared between both users and AWS.</p>
          
            <fig id="fig_2">
              <label>Figure 2</label>
              <caption>
                <title>AWS architecture</title>
              </caption>
              <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_OT1ao5HeWEjpLVLa.jpeg"/>
            </fig>
          
          <p>For that, security groups are created to protect the service against unknown threats. All the services that are created will be maintained by both AWS and the user. The cloud architecture of the deployment for the application is shown in <xref ref-type="fig" rid="fig_3">Figure 3</xref>.</p>
          
            <fig id="fig_3">
              <label>Figure 3</label>
              <caption>
                <title>EKS architecture</title>
              </caption>
              <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_MUEyIkIrQQ_uHWz1.png"/>
            </fig>
          
          <p>The application code and Docker file are uploaded to GitHub. A Docker image is then generated to package the application, which is subsequently deployed to an EKS cluster on AWS. Inside the Kubernetes cluster, Prometheus is set up to collect data and issue alerts if any issues arise. To manage workload fluctuations, HPA is implemented to automatically adjust the number of pods during peak usage or upgrade processes. Helm is utilized as an orchestration tool to ensure seamless application deployment with no downtime. Grafana provides an interactive dashboard to visualize the data and alerts gathered by Prometheus. This setup allows for straightforward interaction with the Kubernetes cluster and efficient use of AWS services.</p>
        </sec>
      
      
        <sec>
          
            <title>3.2. Docker and kubernetes</title>
          
          <p>Kubernetes simplifies the management of applications by automating container-related operational tasks and providing built-in commands for deployment. It facilitates rolling updates, dynamic scaling to meet varying demands, and monitoring. Known as K8s, this open-source container orchestration platform was developed by Google to manage and organize clusters of containerized applications—a process referred to as orchestration.</p><p>In Kubernetes, the smallest deployable units are called Pods, each representing an individual instance of an active process within the cluster. A Pod can contain one or more containers, such as Docker containers, which share resources and are managed collectively. Helm Charts play a crucial role in defining, installing, and upgrading even the most complex Kubernetes applications. Helm is a deployment tool that automates the development, packaging, setup, and distribution of applications to Kubernetes clusters, functioning like a package manager in an operating system. Just as CentOS uses yum and Ubuntu uses apt, Kubernetes employs Helm to manage packaged applications, organized as charts, before deployment.</p><p>With simple command-line interface (CLI) commands, Helm streamlines the installation, updating, and configuration processes in Kubernetes. It significantly reduces the time needed for developers to deploy and test environments, facilitating a smooth transition from development to production. Moreover, Helm provides developers with an efficient way to package and distribute applications for end users. The architecture of Helm is illustrated in <xref ref-type="fig" rid="fig_4">Figure 4</xref>.</p>
          
            <fig id="fig_4">
              <label>Figure 4</label>
              <caption>
                <title>Helm</title>
              </caption>
              <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_hCHtjFcEcBCHSAqN.jpeg"/>
            </fig>
          
          <p>Prometheus is an open-source toolkit designed for monitoring and alerting in containerized environments and microservices. It provides flexible query capabilities and real-time notifications. When issues arise with APIs or other linked applications, Prometheus alerts the IT department, helping them monitor and address problems effectively. The tool also identifies unusual traffic patterns that may indicate potential security threats or vulnerabilities.</p><p>Grafana, developed by Grafana Labs, is an open-source platform for interactive data visualization. It allows users to display their data through a unified dashboard featuring charts and graphs for easier analysis and understanding. Grafana Cloud enhances this experience by integrating metrics, traces, and logs into one cohesive interface.</p>
        </sec>
      
      
        <sec>
          
            <title>3.3. Deployment</title>
          
          <p>A deployment file is created to oversee the application deployment process. To facilitate external access to the application, a service file is utilized to establish a URL or load balancer. Additionally, a horizontal autoscaling file is employed to enable the automatic scaling of pods during application upgrades. The deployment configuration for a Kubernetes object, which can generate and update a set of identical pods, is defined in YAML format. Each pod runs specific containers indicated in the spec.template section of this YAML configuration.</p><p>The Deployment object not only creates the pods but also manages their scalability, oversees continuous updates, and ensures that the correct number of pods is operational in the cluster. Various fields in the deployment YAML are used to configure these functions. An example of the deployment YAML can be found in Appendix A1, detailing how to manage the application deployment.</p><p>In Kubernetes, a Service is a REST object similar to a pod. A service definition can be submitted to the API server to create a new instance, adhering to the label name standards set by RFC 1035. A Service object can also be configured with multiple port definitions. To access the application externally, the YAML service outlined in Appendix A2 must be used.</p>
        </sec>
      
      
        <sec>
          
            <title>3.4. Horizontal auto scaling</title>
          
          <p>By continually updating the workload assets, the proposed HPA in Kubernetes aims to proactively grow the workload following demand. Horizontal scaling is the process of adding new Pods when a load rises. Contrary to vertical scaling, which Kubernetes would imply, the task currently being handled by Pods would receive greater resources. If the load reduces, the HPA notifies the workload resource, installation, stateful set, or additional resource and scales back down. The results of the horizontal pod autoscaling do not affect objects that cannot be scaled. Both a controller and an API resource from the Kubernetes platform are used to implement the HPA. The resource controls the actions of the controller. The metrics like average CPU or memory usage are by the horizontal pod autoscaling controller in the Kubernetes control plane, which modifies the target’s desired scale periodically. When the application is stressed, auto-scaling of pods is deployed using the HPA shown in Appendices A3 and A4. </p><p>The HPA informs the demand on the resource that it should scale back down if the demand decreases and the total amount of Pods is greater than the specified threshold. For stationary things, HPA does not apply. The HPA operates as a controller and a resource in the Kubernetes API. The resource dictates how the controller will act. The Kubernetes control plane's horizontal pod autoscaling controller regularly modifies the objective's target scale to correspond to observable metrics like mean CPU and mean memory utilization. The controller manager does a query on resource utilization against the metric listed in each HPA specification once per period. The controller manager locates the desired resource specified by the scalTargetRe, chooses the pods to use following the target source's requirements, and then retrieves the metrics that are needed using either the resource metrics API for each pod resource metrics or the customized metrics API for remaining all other metrics.</p>
        </sec>
      
    </sec>
    <sec sec-type="">
      <title>4. Results and discussion</title>
      
        <sec>
          
            <title>4.1. Scaling based on pod load</title>
          
          <p>The process of deploying an application on the cloud can be a daunting task, especially when there are multiple services and components involved. However, with the recommended technique, the process becomes more straightforward and efficient. The first step is to transform the application into a Docker image, which is a self-contained package that includes all the dependencies and libraries needed to run it. This image is then deployed on the AWS platform, where all the necessary services are installed. To manage the deployment of the Docker image, the AWS EKS cluster is used. EKS is a fully managed service that simplifies the deployment and scaling of containerized applications. In addition to EKS, a Load Balancer is also used to enable access to the application from outside the system. This LoadBalancer helps to distribute the incoming traffic across the pods in the EKS cluster, ensuring that the application is highly available and responsive. To enable horizontal auto-scaling of the application, Kubernetes is used to automatically scale the pods in the cluster when the system is under stress or any upgrade activity is performed. This ensures that the application can handle increased traffic or workloads without any performance degradation. The Docker image in ECR is shown in Appendix A5.</p><p>To manage the Kubernetes components and ensure zero downtime while upgrading the application, Helm is used. It provides a simple and flexible way to manage the deployment of applications on Kubernetes, making it an ideal tool for managing the deployment of the Docker image. To monitor the EKS cluster and obtain information about its performance, Prometheus is launched inside the cluster. Prometheus is a monitoring system that collects metrics from different sources and stores them in a time series database. Prometheus rules are established to send alarms to email, Slack, Microsoft Team, Opsgenie, and other services, which helps ensure that any issues are promptly addressed. Finally, Grafana is integrated with Prometheus to provide dynamic dashboards that show data about the performance and health of the system. This allows for easy visualization of data and helps identify potential issues before they become critical (see Appendix A6). By combining and optimizing different tools, the suggested technique provides a highly efficient solution for the deployment of containerized applications. The use of continuous integration and deployment using ArgoCD, a declarative GitOps continuous delivery solution based on Kubernetes, also ensures that the application can be easily updated and maintained. Overall, the suggested technique provides a robust and scalable solution for deploying applications on the cloud (scaling of the pod using HPA is shown in Appendix A7). </p>
        </sec>
      
      
        <sec>
          
            <title>4.2. Scaling based on pod load</title>
          
          <p>To assess the proposed strategy, we run several experiments in this part. Since a pod's CPU request in Kubernetes often does not exceed one CPU, our experiment sets consider two CPU request types: 0.5 CPU and 1 CPU. Because many pods are frequently installed on the same host, co-location is also taken into consideration. The tests were run to demand the platform and observe how it responded. First, a preliminary study is done to see if the specific architecture mechanisms such as scalability and work queuing are following SLOs. Following that, a comprehensive result analysis is carried out to gain insight into the platform's normal behavior and identify instances in which it performs better than a conventional Kubernetes cluster (see <xref ref-type="fig" rid="fig_5">Figure 5</xref>).</p>
          
            <fig id="fig_5">
              <label>Figure 5</label>
              <caption>
                <title>Queue length and CPU utilization of Pod</title>
              </caption>
              <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_Z9Lhbe3EZgHIJapu.png"/>
            </fig>
          
          <p>Thus, our goal is to demonstrate the circumstances in which the suggested QoS technique improves upon existing tools like the default QoS methods in Kubernetes and gets higher performance in terms of using computational resources while resolving some of the problems with typical Kubernetes clusters. Since CPU and memory utilization are the tracked metrics under the current system, they are also the focus of this results section. To replicate stressful situations, CPU and memory wasters were used in a setting that included older apps, APIs, databases, and other tools. This section demonstrates the system's reaction. All of these systems would ideally cooperate and share resources. The CPU utilization Grafana dashboard is shown in Appendix A4. The results of this study show that observing QoS restrictions is essential for guaranteeing security satisfaction. The execution findings demonstrate the proposed architecture's potential for maintaining compliance with security requirements at both the software and computer hardware levels. Even though the measurements used, focused on CPU and memory utilization, are encouraging, the system's effectiveness in terms of common security requirements. However, this solution is still far from being finished and commercially viable. The tests made clear some problems that must be resolved before using the architecture commercially. The platform would be regarded as being in its bare minimum marketable condition if these conditions were satisfied. On the other hand, several enhancements are desired to simplify deployment, enhance performance, and therefore, improve the user experience. It would be possible to reduce in-script modifications by using global configurations in the cloud that include parameters for every service in the architecture. Next, each supported programming language should have a separate procedure submission that is suited to it. As a result, dependencies would be minimized, and there would be transparency.</p>
        </sec>
      
    </sec>
    <sec sec-type="conclusions">
      <title>5. Conclusions</title>
      <p>The proposed methodology is for monitoring and alerting of auto-scaling pods in Kubernetes using Prometheus in cloud computing with AWS as the cloud provider. The suggested technique deployed all services to build the necessary infrastructure for deploying the application in the EKS cluster. Helm orchestrates Kubernetes cluster deployment, service, and horizontal auto-scaling. Prometheus is installed within the Kubernetes cluster and is used to scrape all data about the cluster in which the application is deployed. Grafana is used to present an interactive dashboard with alarms and information about the Kubernetes cluster, where data is scraped from the cluster using Prometheus. </p><p>The recommended solution eventually resulted in the application being deployed with minimal downtime once the upgrading work was completed. When the application is affected by any security attacks, the pods are scaled using Kubernetes' horizontal autoscaling feature. In conclusion, all of these findings support carrying out the proposed research in a cloud environment. They suggest that this is the route for improving the QoS awareness, automaticity, security, and robustness of the current cloud systems. </p><p>In the future, the proposed work can be tested with vertical auto-scaling of pods with security requirements.</p>
    </sec>
  </body>
  <back>
    <ack>
      <title>Acknowledgments</title>
      
    </ack>
    <app-group>
      <app>
        <title>Appendix</title>
        <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_5WYc6ey27xu1flXv.jpeg" /><p style="text-align: center">A1. Deployment.yaml</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_It7BPqXelY8sV7A5.jpeg" /><p style="text-align: center">A2. Service.yaml</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_udRc99U9mjtX2rg6.png" /><p style="text-align: center">A3. Hpa.yaml</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_a9qjXWeeqNgIgmV0.png" /><p style="text-align: center">A4. Value.yaml</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_8aUwB06VqPu1e4Nu.jpeg" /><p style="text-align: center">A5. Docker image in ECR</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_WnJKb-m7jJuSCfY4.jpeg" /><p style="text-align: center">A6. Scaling of pods in HPA</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://media.acadlore.com/assets/media/2024/9/img_VmzVWFSdrSPLXemB.png" /><p style="text-align: center">A7. CPU utilization in Grafana</p>
      </app>
    </app-group>
    <notes>
      <title>Author Contributions</title>
      
    </notes>
    <notes>
      <title>Funding</title>
      
    </notes>
    <notes>
      <title>Informed Consent Statement</title>
      
    </notes>
    <notes>
      <title>Data Availability Statement</title>
      <p>The data used to support the research findings are available from the corresponding author upon request.</p>
    </notes>
    <notes notes-type="COI-statement">
      <title>Conflicts of Interest</title>
      <p>The authors declare no conflict of interest.</p>
    </notes>
    <ref-list>
      <title>References</title>
      <ref id="ref_1">
        <label>1.</label>
        <element-citation publication-type="conf-paper">
          <page-range>1-5</page-range>
          <year>2020</year>
          <person-group person-group-type="author">
            <name>
              <surname>Balla</surname>
              <given-names>D.</given-names>
            </name>
            <name>
              <surname>Simon</surname>
              <given-names>C.</given-names>
            </name>
            <name>
              <surname>Maliosz</surname>
              <given-names>M.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1109/NOMS47738.2020.9110428</pub-id>
          <article-title>Adaptive scaling of Kubernetes pods</article-title>
          <source>NOMS 2020-2020 IEEE/IFIP Network Operations and Management Symposium, Budapest, Hungary</source>
        </element-citation>
      </ref>
      <ref id="ref_2">
        <label>2.</label>
        <element-citation publication-type="journal">
          <volume>20</volume>
          <page-range>4621</page-range>
          <issue>16</issue>
          <year>2020</year>
          <person-group person-group-type="author">
            <name>
              <surname>Nguyen</surname>
              <given-names>Thanh Tung</given-names>
            </name>
            <name>
              <surname>Yeom</surname>
              <given-names>Yu Jin</given-names>
            </name>
            <name>
              <surname>Kim</surname>
              <given-names>Taehong</given-names>
            </name>
            <name>
              <surname>Park</surname>
              <given-names>Dae Heon</given-names>
            </name>
            <name>
              <surname>Kim</surname>
              <given-names>Sehan</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.3390/s20164621</pub-id>
          <article-title>Horizontal pod autoscaling in Kubernetes for elastic container orchestration</article-title>
          <source>Sensors</source>
        </element-citation>
      </ref>
      <ref id="ref_3">
        <label>3.</label>
        <element-citation publication-type="journal">
          <year>2021</year>
          <person-group person-group-type="author">
            <name>
              <surname>Ben David</surname>
              <given-names>Ronen</given-names>
            </name>
            <name>
              <surname>Bremler Barr</surname>
              <given-names>Anat</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.48550/arXiv.2105.00542</pub-id>
          <article-title>Kubernetes autoscaling: YoYo attack vulnerability and mitigation</article-title>
          <source>arXiv e-prints</source>
        </element-citation>
      </ref>
      <ref id="ref_4">
        <label>4.</label>
        <element-citation publication-type="journal">
          <volume>10</volume>
          <page-range>18966-18977</page-range>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Phuc</surname>
              <given-names>L. H.</given-names>
            </name>
            <name>
              <surname>Phan</surname>
              <given-names>L.</given-names>
            </name>
            <name>
              <surname>Kim</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1109/access.2022.3150867</pub-id>
          <article-title>Traffic-aware horizontal pod autoscaler in Kubernetes-based edge computing infrastructure</article-title>
          <source>IEEE Access</source>
        </element-citation>
      </ref>
      <ref id="ref_5">
        <label>5.</label>
        <element-citation publication-type="conf-paper">
          <volume>2019</volume>
          <page-range>1411–1415</page-range>
          <year>2019</year>
          <person-group person-group-type="author">
            <name>
              <surname>Khaleq</surname>
              <given-names>A. A.</given-names>
            </name>
            <name>
              <surname>Ra</surname>
              <given-names>I.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1109/csci49370.2019.00264</pub-id>
          <article-title>Agnostic approach for microservices autoscaling in cloud applications</article-title>
          <source>2019 International Conference on Computational Science and Computational Intelligence (CSCI), Las Vegas, NV, USA</source>
        </element-citation>
      </ref>
      <ref id="ref_6">
        <label>6.</label>
        <element-citation publication-type="journal">
          <volume>18</volume>
          <page-range>101111</page-range>
          <year>2023</year>
          <person-group person-group-type="author">
            <name>
              <surname>Rajasekar</surname>
              <given-names>V.</given-names>
            </name>
            <name>
              <surname>Vaishnnave</surname>
              <given-names>M. P.</given-names>
            </name>
            <name>
              <surname>Premkumar</surname>
              <given-names>S.</given-names>
            </name>
            <name>
              <surname>Sarveshwaran</surname>
              <given-names>V.</given-names>
            </name>
            <name>
              <surname>Rangaraaj</surname>
              <given-names>V.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1016/j.rineng.2023.101111</pub-id>
          <article-title>Lung cancer disease prediction with CT scan and histopathological images feature analysis using deep learning techniques</article-title>
          <source>Results Eng.</source>
        </element-citation>
      </ref>
      <ref id="ref_7">
        <label>7.</label>
        <element-citation publication-type="journal">
          <volume>74</volume>
          <page-range>591-606</page-range>
          <issue>1</issue>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Niazi</surname>
              <given-names>M.</given-names>
            </name>
            <name>
              <surname>Abbas</surname>
              <given-names>S.</given-names>
            </name>
            <name>
              <surname>Soliman</surname>
              <given-names>A. H.</given-names>
            </name>
            <name>
              <surname>Alyas</surname>
              <given-names>T.</given-names>
            </name>
            <name>
              <surname>Asif</surname>
              <given-names>S.</given-names>
            </name>
            <name>
              <surname>Faiz</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.32604/cmc.2023.032474</pub-id>
          <article-title>Vertical Pod Autoscaling in Kubernetes for elastic container collaborative framework</article-title>
          <source>Comput. Mater. Continua</source>
        </element-citation>
      </ref>
      <ref id="ref_8">
        <label>8.</label>
        <element-citation publication-type="journal">
          <volume>26</volume>
          <page-range>2789-2800</page-range>
          <issue>5</issue>
          <year>2023</year>
          <person-group person-group-type="author">
            <name>
              <surname>Abdel Khaleq</surname>
              <given-names>Abeer</given-names>
            </name>
            <name>
              <surname>Ra</surname>
              <given-names>Ilkyeun</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1007/s10586-023-03999-8</pub-id>
          <article-title>Intelligent microservices autoscaling module using reinforcement learning</article-title>
          <source>Cluster Comput.</source>
        </element-citation>
      </ref>
      <ref id="ref_9">
        <label>9.</label>
        <element-citation publication-type="journal">
          <volume>16</volume>
          <page-range>163101</page-range>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Zhu</surname>
              <given-names>C. P.</given-names>
            </name>
            <name>
              <surname>Han</surname>
              <given-names>B.</given-names>
            </name>
            <name>
              <surname>Zhao</surname>
              <given-names>Y. L.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1007/s11704-021-0118-1</pub-id>
          <article-title>A bi-metric autoscaling approach for N-tier web applications on Kubernetes</article-title>
          <source>Front. Comput. Sci.</source>
        </element-citation>
      </ref>
      <ref id="ref_10">
        <label>10.</label>
        <element-citation publication-type="journal">
          <volume>10</volume>
          <page-range>33083-33094</page-range>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Ruíz</surname>
              <given-names>L. M.</given-names>
            </name>
            <name>
              <surname>Pueyo</surname>
              <given-names>P. P.</given-names>
            </name>
            <name>
              <surname>Mateo-Fornés</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Mayoral</surname>
              <given-names>J. V.</given-names>
            </name>
            <name>
              <surname>Tehàs</surname>
              <given-names>F. S.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1109/access.2022.3158743</pub-id>
          <article-title>Autoscaling pods on an on-premise Kubernetes infrastructure QoS-aware</article-title>
          <source>IEEE Access</source>
        </element-citation>
      </ref>
      <ref id="ref_11">
        <label>11.</label>
        <element-citation publication-type="conference-proceedings">
          <volume>37</volume>
          <page-range>15621-15629</page-range>
          <issue>13</issue>
          <year>2023</year>
          <person-group person-group-type="author">
            <name>
              <surname>Zhou</surname>
              <given-names>Z.</given-names>
            </name>
            <name>
              <surname>Zhang</surname>
              <given-names>C.</given-names>
            </name>
            <name>
              <surname>Ma</surname>
              <given-names>L.</given-names>
            </name>
            <name>
              <surname>Gu</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Qian</surname>
              <given-names>H.</given-names>
            </name>
            <name>
              <surname>Wen</surname>
              <given-names>Q. S.</given-names>
            </name>
            <name>
              <surname>Sun</surname>
              <given-names>L.</given-names>
            </name>
            <name>
              <surname>Li</surname>
              <given-names>P.</given-names>
            </name>
            <name>
              <surname>Tang</surname>
              <given-names>Z. M.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1609/aaai.v37i13.26852</pub-id>
          <article-title>AHPA: Adaptive horizontal pod autoscaling systems on alibaba cloud container service for Kubernetes</article-title>
          <source>, </source>
        </element-citation>
      </ref>
      <ref id="ref_12">
        <label>12.</label>
        <element-citation publication-type="journal">
          <volume>11</volume>
          <page-range>684</page-range>
          <issue>12</issue>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Rajasekar</surname>
              <given-names>Vani</given-names>
            </name>
            <name>
              <surname>Saračević</surname>
              <given-names>Muzafer</given-names>
            </name>
            <name>
              <surname>Karabašević</surname>
              <given-names>Darjan</given-names>
            </name>
            <name>
              <surname>Stanujkić</surname>
              <given-names>Dragiša</given-names>
            </name>
            <name>
              <surname>Dobardžić</surname>
              <given-names>Eldin</given-names>
            </name>
            <name>
              <surname>Krishnamoorthi</surname>
              <given-names>Sathya</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.3390/axioms11120684</pub-id>
          <article-title>Efficient cancelable template generation based on signcryption and bio hash function</article-title>
          <source>Axioms</source>
        </element-citation>
      </ref>
      <ref id="ref_13">
        <label>13.</label>
        <element-citation publication-type="journal">
          <volume>11</volume>
          <page-range>2675</page-range>
          <issue>12</issue>
          <year>2023</year>
          <person-group person-group-type="author">
            <name>
              <surname>Mondal</surname>
              <given-names>S. K.</given-names>
            </name>
            <name>
              <surname>Wu</surname>
              <given-names>X.</given-names>
            </name>
            <name>
              <surname>Kabir</surname>
              <given-names>H. M. D.</given-names>
            </name>
            <name>
              <surname>Dai</surname>
              <given-names>H. N.</given-names>
            </name>
            <name>
              <surname>Ni</surname>
              <given-names>K.</given-names>
            </name>
            <name>
              <surname>H. G. Yuan</surname>
            </name>
            <name>
              <surname>Wang</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.3390/math11122675</pub-id>
          <article-title>Toward optimal load prediction and customizable autoscaling scheme for Kubernetes</article-title>
          <source>Mathematics</source>
        </element-citation>
      </ref>
      <ref id="ref_14">
        <label>14.</label>
        <element-citation publication-type="conf-paper">
          <volume>2022</volume>
          <page-range>263–265</page-range>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Tran</surname>
              <given-names>M. N.</given-names>
            </name>
            <name>
              <surname>Vu</surname>
              <given-names>D. D.</given-names>
            </name>
            <name>
              <surname>Kim</surname>
              <given-names>Y.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1109/icufn55119.2022.9829572</pub-id>
          <article-title>A survey of autoscaling in Kubernetes</article-title>
          <source>2022 Thirteenth International Conference on Ubiquitous and Future Networks (ICUFN), Barcelona, Spain</source>
        </element-citation>
      </ref>
      <ref id="ref_15">
        <label>15.</label>
        <element-citation publication-type="journal">
          <volume>10</volume>
          <page-range>109768-109778</page-range>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Vu</surname>
              <given-names>D. D.</given-names>
            </name>
            <name>
              <surname>M. N. Tran</surname>
            </name>
            <name>
              <surname>Kim</surname>
              <given-names>Y.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1109/access.2022.3214985</pub-id>
          <article-title>Predictive hybrid autoscaling for containerized applications</article-title>
          <source>IEEE Access</source>
        </element-citation>
      </ref>
      <ref id="ref_16">
        <label>16.</label>
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Horn</surname>
              <given-names>A.</given-names>
            </name>
            <name>
              <surname>Fard</surname>
              <given-names>H. M.</given-names>
            </name>
            <name>
              <surname>Wolf</surname>
              <given-names>F.</given-names>
            </name>
          </person-group>
          <article-title>Multi-objective hybrid autoscaling of microservices in Kubernetes clusters</article-title>
          <source>Lecture Notes in Computer Science</source>
          <publisher-name>Springer, Cham</publisher-name>
          <year>2022</year>
          <page-range>233-250</page-range>
          <pub-id pub-id-type="doi">10.1007/978-3-031-12597-3_15</pub-id>
        </element-citation>
      </ref>
      <ref id="ref_17">
        <label>17.</label>
        <element-citation publication-type="journal">
          <volume>30</volume>
          <page-range>35-49</page-range>
          <issue>1</issue>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Krishnamoorthi</surname>
              <given-names>Sathya</given-names>
            </name>
            <name>
              <surname>Jayapaul</surname>
              <given-names>Premalatha</given-names>
            </name>
            <name>
              <surname>Rajasekar</surname>
              <given-names>Vani</given-names>
            </name>
            <name>
              <surname>Dhanaraj</surname>
              <given-names>Rajesh Kumar</given-names>
            </name>
            <name>
              <surname>Iwendi</surname>
              <given-names>Celestine</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.3906/elk-2010-137</pub-id>
          <article-title>A futuristic approach to generate random bit sequence using dynamic perturbed chaotic system</article-title>
          <source>Turk. J. Electr. Eng. Comput. Sci.</source>
        </element-citation>
      </ref>
      <ref id="ref_18">
        <label>18.</label>
        <element-citation publication-type="journal">
          <volume>20</volume>
          <page-range>40</page-range>
          <issue>4</issue>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Dogani</surname>
              <given-names>J.</given-names>
            </name>
            <name>
              <surname>Khunjush</surname>
              <given-names>F.</given-names>
            </name>
            <name>
              <surname>Seydali</surname>
              <given-names>M.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1007/s10723-022-09634-x</pub-id>
          <article-title>K-agrued: A container autoscaling technique for cloud-based web applications in Kubernetes using attention-based GRU encoder-decoder</article-title>
          <source>Journal of Grid Computing</source>
        </element-citation>
      </ref>
      <ref id="ref_19">
        <label>19.</label>
        <element-citation publication-type="conf-paper">
          <volume>2022</volume>
          <page-range>163-169</page-range>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Spatharakis</surname>
              <given-names>D.</given-names>
            </name>
            <name>
              <surname>Dimolitsas</surname>
              <given-names>I.</given-names>
            </name>
            <name>
              <surname>Vlahakis</surname>
              <given-names>E.</given-names>
            </name>
            <name>
              <surname>Dechouniotis</surname>
              <given-names>D.</given-names>
            </name>
            <name>
              <surname>Athanasopoulos</surname>
              <given-names>N.</given-names>
            </name>
            <name>
              <surname>Papavassiliou</surname>
              <given-names>S.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.23919/cnsm55787.2022.9965056</pub-id>
          <article-title>Distributed resource autoscaling in Kubernetes edge clusters</article-title>
          <source>2022 18th International Conference on Network and Service Management (CNSM), Thessaloniki, Greece</source>
        </element-citation>
      </ref>
      <ref id="ref_20">
        <label>20.</label>
        <element-citation publication-type="conf-paper">
          <volume>2022</volume>
          <page-range>1–2</page-range>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Joyce</surname>
              <given-names>J. E.</given-names>
            </name>
            <name>
              <surname>Sebastian</surname>
              <given-names>S.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1109/phdedits56681.2022.9955300</pub-id>
          <article-title>Reinforcement learning based autoscaling for Kafka-centric microservices in Kubernetes</article-title>
          <source>2022 IEEE 4th PhD Colloquium on Emerging Domain Innovation and Technology for Society (PhD EDITS), Bangalore, India</source>
        </element-citation>
      </ref>
      <ref id="ref_21">
        <label>21.</label>
        <element-citation publication-type="conf-paper">
          <volume>29</volume>
          <page-range>57</page-range>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Sfiligoi</surname>
              <given-names>I.</given-names>
            </name>
            <name>
              <surname>DeFanti</surname>
              <given-names>T.</given-names>
            </name>
            <name>
              <surname>Würthwein</surname>
              <given-names>F.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1145/3491418.3535123</pub-id>
          <article-title>Auto-scaling HTCondor pools using Kubernetes compute resources</article-title>
          <source>Practice and Experience in Advanced Research Computing, Boston MA, USA</source>
        </element-citation>
      </ref>
      <ref id="ref_22">
        <label>22.</label>
        <element-citation publication-type="journal">
          <volume>55</volume>
          <page-range>1-37</page-range>
          <issue>7</issue>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Carrión</surname>
              <given-names>C.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1145/3539606</pub-id>
          <article-title>Kubernetes scheduling: Taxonomy, ongoing issues and challenges</article-title>
          <source>ACM Computing Surveys</source>
        </element-citation>
      </ref>
      <ref id="ref_23">
        <label>23.</label>
        <element-citation publication-type="conf-paper">
          <volume>7161</volume>
          <page-range>1-6</page-range>
          <year>2022</year>
          <person-group person-group-type="author">
            <name>
              <surname>Pramesti</surname>
              <given-names>A. A.</given-names>
            </name>
            <name>
              <surname>Kistijantoro</surname>
              <given-names>A. I.</given-names>
            </name>
          </person-group>
          <pub-id pub-id-type="doi">10.1109/icaicta56449.2022.9932943</pub-id>
          <article-title>Autoscaling based on response time prediction for microservice application in Kubernetes</article-title>
          <source>2022 9th International Conference on Advanced Informatics: Concepts, Theory and Applications (ICAICTA), Tokoname, Japan</source>
        </element-citation>
      </ref>
    </ref-list>
  </back>
</article>